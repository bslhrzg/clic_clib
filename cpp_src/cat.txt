// ci_core.cpp
#include "ci_core.h"

#include <unordered_set>
#include <bit>          // std::popcount, std::countr_zero
#include <cassert>
#include <algorithm>
#include <stdexcept>
#include <cmath>
#include <sstream>
#include <bitset>

#include <omp.h>

namespace ci {

// ============================== BitsetVec ====================================

BitsetVec::BitsetVec() = default;

BitsetVec::BitsetVec(std::size_t n_bits)
    : n_bits_(n_bits), words_((n_bits + 63) / 64, u64{0}) {}

std::size_t BitsetVec::size()   const noexcept { return n_bits_; }
std::size_t BitsetVec::nwords() const noexcept { return words_.size(); }

bool BitsetVec::test(std::size_t bit) const noexcept {
    assert(bit < n_bits_);
    const auto w = bit / 64, b = bit % 64;
    return (words_[w] >> b) & u64{1};
}

void BitsetVec::set(std::size_t bit) noexcept {
    assert(bit < n_bits_);
    const auto w = bit / 64, b = bit % 64;
    words_[w] |= (u64{1} << b);
}

void BitsetVec::reset(std::size_t bit) noexcept {
    assert(bit < n_bits_);
    const auto w = bit / 64, b = bit % 64;
    words_[w] &= ~(u64{1} << b);
}

void BitsetVec::clear() noexcept {
    std::fill(words_.begin(), words_.end(), u64{0});
}

std::size_t BitsetVec::popcount_all() const noexcept {
    std::size_t c = 0;
    for (u64 w : words_) c += std::popcount(w);
    return c;
}

// Count set bits in [0, bit_exclusive)
std::size_t BitsetVec::popcount_below(std::size_t bit_exclusive) const noexcept {
    if (bit_exclusive == 0) return 0;
    auto idx = bit_exclusive - 1;
    const auto wlim = idx / 64;
    const auto blim = idx % 64;
    std::size_t c = 0;
    for (std::size_t w = 0; w < wlim; ++w) c += std::popcount(words_[w]);
    const u64 mask = (blim == 63) ? ~u64{0} : ((u64{1} << (blim + 1)) - 1);
    c += std::popcount(words_[wlim] & mask);
    return c;
}

void BitsetVec::mask_tail() noexcept {
    if (words_.empty()) return;
    const std::size_t valid = n_bits_ % 64;
    if (valid == 0) return;
    const u64 mask = (u64{1} << valid) - 1;
    words_.back() &= mask;
}

std::string BitsetVec::to_binary() const {
    std::stringstream ss;
    for (auto it = words_.rbegin(); it != words_.rend(); ++it)
        ss << std::bitset<64>(*it).to_string();
    auto s = ss.str();
    if (n_bits_ == 0) return s;
    return s.substr(s.size() - n_bits_);
}

BitsetVec::OccIter::OccIter() = default;

BitsetVec::OccIter::OccIter(const BitsetVec* bs, std::size_t start)
    : bs_(bs)
{
    if (!bs_ || start >= bs_->n_bits_) { done_ = true; return; }
    idx_ = start; w_ = idx_ / 64; b_ = idx_ % 64;
    advance_to_next();
}

void BitsetVec::OccIter::advance_to_next() {
    done_ = true;
    while (w_ < bs_->nwords()) {
        u64 word = bs_->words_[w_];
        if (b_) word &= (~u64{0} << b_);           // clear lower bits
        if (word) {
            unsigned tz = std::countr_zero(word);
            std::size_t bit = w_ * 64 + tz;
            if (bit < bs_->n_bits_) {
                idx_ = bit + 1;
                w_   = idx_ / 64;
                b_   = idx_ % 64;
                current0_ = static_cast<int>(bit);
                done_ = false;
                return;
            }
        }
        ++w_; b_ = 0;
    }
}

int BitsetVec::OccIter::operator*() const noexcept { return current0_; }

BitsetVec::OccIter& BitsetVec::OccIter::operator++() { advance_to_next(); return *this; }

bool BitsetVec::OccIter::operator!=(const OccIter& other) const noexcept {
    // end() is represented by done_==true
    return done_ != other.done_;
}

BitsetVec::OccIter BitsetVec::begin_occ() const { return OccIter(this, 0); }
BitsetVec::OccIter BitsetVec::end_occ()   const { return OccIter(); }

bool operator==(const BitsetVec& a, const BitsetVec& b) noexcept {
    return a.n_bits_ == b.n_bits_ && a.words_ == b.words_;
}
bool operator<(const BitsetVec& a, const BitsetVec& b) noexcept {
    if (a.n_bits_ != b.n_bits_) return a.n_bits_ < b.n_bits_;
    return std::lexicographical_compare(a.words_.begin(), a.words_.end(),
                                        b.words_.begin(), b.words_.end());
}

// =============================== Determinant =================================

Determinant::Determinant() = default;

Determinant::Determinant(std::size_t total_orbitals)
    : bits_(total_orbitals) {}

Determinant::Determinant(std::size_t total_orbitals, const std::vector<int>& occupied0)
    : bits_(total_orbitals)
{
    for (int k0 : occupied0) {
        if (k0 < 0 || static_cast<std::size_t>(k0) >= total_orbitals)
            throw std::out_of_range("Determinant: orbital index out of range (0-based).");
        bits_.set(static_cast<std::size_t>(k0));
    }
    bits_.mask_tail();
}

std::size_t Determinant::num_orbitals() const noexcept { return bits_.size(); }

bool Determinant::occupied(std::size_t orb0) const noexcept { return bits_.test(orb0); }
void Determinant::set     (std::size_t orb0) noexcept { bits_.set(orb0); }
void Determinant::reset   (std::size_t orb0) noexcept { bits_.reset(orb0); }

std::size_t Determinant::count_electrons() const noexcept { return bits_.popcount_all(); }

BitsetVec::OccIter Determinant::begin_occ() const { return bits_.begin_occ(); }
BitsetVec::OccIter Determinant::end_occ()   const { return bits_.end_occ();   }

std::string Determinant::to_string_binary() const { return bits_.to_binary(); }

bool operator==(const Determinant& a, const Determinant& b) noexcept { return a.bits_ == b.bits_; }
bool operator<( const Determinant& a, const Determinant& b) noexcept { return a.bits_ <  b.bits_; }

const BitsetVec& Determinant::bits() const noexcept { return bits_; }

// ============================== SpinDeterminant ==============================

SpinDeterminant::SpinDeterminant() = default;

SpinDeterminant::SpinDeterminant(std::size_t n_spatial)
    : bits_(n_spatial) {}

SpinDeterminant::SpinDeterminant(std::size_t n_spatial, const std::vector<int>& occupied0)
    : bits_(n_spatial)
{
    for (int i0 : occupied0) {
        if (i0 < 0 || static_cast<std::size_t>(i0) >= n_spatial)
            throw std::out_of_range("SpinDeterminant: spatial index out of range (0-based).");
        bits_.set(static_cast<std::size_t>(i0));
    }
    bits_.mask_tail();
}

std::size_t SpinDeterminant::num_orbitals() const noexcept { return bits_.size(); }
bool        SpinDeterminant::occupied(std::size_t i0) const noexcept { return bits_.test(i0); }
void        SpinDeterminant::set     (std::size_t i0) noexcept { bits_.set(i0); }
void        SpinDeterminant::reset   (std::size_t i0) noexcept { bits_.reset(i0); }
std::size_t SpinDeterminant::count_electrons() const noexcept { return bits_.popcount_all(); }

BitsetVec::OccIter SpinDeterminant::begin_occ() const { return bits_.begin_occ(); }
BitsetVec::OccIter SpinDeterminant::end_occ()   const { return bits_.end_occ();   }

const BitsetVec& SpinDeterminant::raw() const noexcept { return bits_; }

bool operator==(const SpinDeterminant& a, const SpinDeterminant& b) noexcept { return a.bits_ == b.bits_; }
bool operator<( const SpinDeterminant& a, const SpinDeterminant& b) noexcept { return a.bits_ <  b.bits_; }

// sign = (-1)^{N(<i)} with N counting occupied bits strictly below i.
std::optional<SpinDeterminant::OpResult>
SpinDeterminant::create(const SpinDeterminant& d, std::size_t i0) noexcept {
    if (i0 >= d.num_orbitals()) return std::nullopt;
    if (d.occupied(i0))         return std::nullopt; // Pauli
    SpinDeterminant out = d;
    const auto N_below = d.raw().popcount_below(i0);
    const int8_t sgn   = (N_below % 2 == 0) ? +1 : -1;
    out.set(i0);
    return OpResult{ std::move(out), sgn };
}

std::optional<SpinDeterminant::OpResult>
SpinDeterminant::annihilate(const SpinDeterminant& d, std::size_t i0) noexcept {
    if (i0 >= d.num_orbitals()) return std::nullopt;
    if (!d.occupied(i0))        return std::nullopt; // Pauli
    SpinDeterminant out = d;
    const auto N_below = d.raw().popcount_below(i0);
    const int8_t sgn   = (N_below % 2 == 0) ? +1 : -1;
    out.reset(i0);
    return OpResult{ std::move(out), sgn };
}

// ============================== SlaterDeterminant ============================

SlaterDeterminant::SlaterDeterminant() = default;

SlaterDeterminant::SlaterDeterminant(std::size_t n_spatial)
    : n_spatial_(n_spatial), alpha_(n_spatial), beta_(n_spatial) {}

SlaterDeterminant::SlaterDeterminant(std::size_t n_spatial,
                                     const std::vector<int>& occ_alpha0,
                                     const std::vector<int>& occ_beta0)
    : n_spatial_(n_spatial), alpha_(n_spatial, occ_alpha0), beta_(n_spatial, occ_beta0) {}

std::size_t            SlaterDeterminant::num_spatial_orbitals() const noexcept { return n_spatial_; }
const SpinDeterminant& SlaterDeterminant::alpha() const noexcept { return alpha_; }
const SpinDeterminant& SlaterDeterminant::beta () const noexcept { return beta_;  }
SpinDeterminant& SlaterDeterminant::alpha() noexcept { return alpha_; }
SpinDeterminant& SlaterDeterminant::beta()  noexcept { return beta_;  }

std::size_t SlaterDeterminant::count_electrons() const noexcept {
    return alpha_.count_electrons() + beta_.count_electrons();
}
double SlaterDeterminant::Sz() const noexcept {
    return 0.5 * (static_cast<double>(alpha_.count_electrons()) -
                  static_cast<double>(beta_.count_electrons()));
}

bool operator==(const SlaterDeterminant& a, const SlaterDeterminant& b) noexcept {
    return a.n_spatial_ == b.n_spatial_ && a.alpha_ == b.alpha_ && a.beta_ == b.beta_;
}
bool operator<(const SlaterDeterminant& a, const SlaterDeterminant& b) noexcept {
    if (a.n_spatial_ != b.n_spatial_) return a.n_spatial_ < b.n_spatial_;
    if (a.alpha_     != b.alpha_)     return a.alpha_     < b.alpha_;
    return a.beta_ < b.beta_;
}

static inline int8_t apply_beta_order_sign(int8_t sgn, const SlaterDeterminant& s,
                                           std::size_t i0, SpinOrbitalOrder order)
{
    if (order == SpinOrbitalOrder::AlphaFirst) {
        // β sector is placed after all α orbitals; crossing Nα electrons.
        return (s.alpha().count_electrons() % 2) ? int8_t(-sgn) : sgn;
    } else {
        // Interleaved: (α0,β0,α1,β1,...). For β_i, you cross α_j for j<=i.
        const auto Nalpha_le_i = s.alpha().raw().popcount_below(i0 + 1);
        return (Nalpha_le_i % 2) ? int8_t(-sgn) : sgn;
    }
}

std::optional<SlaterDeterminant::OpResult>
SlaterDeterminant::create(const SlaterDeterminant& s, std::size_t i0, Spin spin,
                          SpinOrbitalOrder order) noexcept
{
    if (i0 >= s.n_spatial_) return std::nullopt;

    if (spin == Spin::Alpha) {
        auto r = SpinDeterminant::create(s.alpha_, i0);
        if (!r) return std::nullopt;
        SlaterDeterminant out = s;
        out.alpha_ = std::move(r->det);
        return OpResult{ std::move(out), r->sign };
    } else {
        auto r = SpinDeterminant::create(s.beta_, i0);
        if (!r) return std::nullopt;
        int8_t sign = apply_beta_order_sign(r->sign, s, i0, order);
        SlaterDeterminant out = s;
        out.beta_ = std::move(r->det);
        return OpResult{ std::move(out), sign };
    }
}

std::optional<SlaterDeterminant::OpResult>
SlaterDeterminant::annihilate(const SlaterDeterminant& s, std::size_t i0, Spin spin,
                              SpinOrbitalOrder order) noexcept
{
    if (i0 >= s.n_spatial_) return std::nullopt;

    if (spin == Spin::Alpha) {
        auto r = SpinDeterminant::annihilate(s.alpha_, i0);
        if (!r) return std::nullopt;
        SlaterDeterminant out = s;
        out.alpha_ = std::move(r->det);
        return OpResult{ std::move(out), r->sign };
    } else {
        auto r = SpinDeterminant::annihilate(s.beta_, i0);
        if (!r) return std::nullopt;
        int8_t sign = apply_beta_order_sign(r->sign, s, i0, order);
        SlaterDeterminant out = s;
        out.beta_ = std::move(r->det);
        return OpResult{ std::move(out), sign };
    }
}

// ========================== Interleave / Deinterleave ========================

Determinant interleave(const SlaterDeterminant& s, SpinOrbitalOrder order)
{
    const auto M = s.num_spatial_orbitals();
    Determinant d(2 * M);

    if (order == SpinOrbitalOrder::AlphaFirst) {
        // α at [0..M-1], β at [M..2M-1]
        for (auto it = s.alpha().begin_occ(); it != s.alpha().end_occ(); ++it) {
            const std::size_t i0 = static_cast<std::size_t>(*it);
            d.set(i0);
        }
        for (auto it = s.beta().begin_occ(); it != s.beta().end_occ(); ++it) {
            const std::size_t i0 = static_cast<std::size_t>(*it);
            d.set(M + i0);
        }
    } else {
        // Interleaved: α_i -> 2*i, β_i -> 2*i+1
        for (auto it = s.alpha().begin_occ(); it != s.alpha().end_occ(); ++it) {
            const std::size_t i0 = static_cast<std::size_t>(*it);
            d.set(2 * i0);
        }
        for (auto it = s.beta().begin_occ(); it != s.beta().end_occ(); ++it) {
            const std::size_t i0 = static_cast<std::size_t>(*it);
            d.set(2 * i0 + 1);
        }
    }
    return d;
}

SlaterDeterminant deinterleave(const Determinant& d, SpinOrbitalOrder order)
{
    const auto K = d.num_orbitals();
    if (K % 2 != 0) throw std::invalid_argument("deinterleave: number of spin-orbitals must be even.");
    const auto M = K / 2;

    std::vector<int> occ_a, occ_b;
    occ_a.reserve(M); occ_b.reserve(M);

    if (order == SpinOrbitalOrder::AlphaFirst) {
        for (auto it = d.begin_occ(); it != d.end_occ(); ++it) {
            const std::size_t p0 = static_cast<std::size_t>(*it);
            if (p0 < M) occ_a.push_back(static_cast<int>(p0));
            else        occ_b.push_back(static_cast<int>(p0 - M));
        }
    } else {
        for (auto it = d.begin_occ(); it != d.end_occ(); ++it) {
            const std::size_t p0 = static_cast<std::size_t>(*it);
            const std::size_t i0 = p0 / 2;
            if ((p0 % 2) == 0) occ_a.push_back(static_cast<int>(i0));
            else               occ_b.push_back(static_cast<int>(i0));
        }
    }

    return SlaterDeterminant(M, occ_a, occ_b);
}

// ======================= SlaterDeterminant Fast Operators =======================
// This section implements suggestion (B)

// Helper to calculate sign for a single creation or annihilation on a SpinDeterminant
// Returns false if Pauli-blocked.
inline bool op_sign(const SpinDeterminant& d, size_t i0, bool create, int8_t& sign) {
    if (create) {
        if (d.occupied(i0)) return false; // Pauli block
        const auto N_below = d.raw().popcount_below(i0);
        sign = (N_below % 2 == 0) ? +1 : -1;
    } else {
        if (!d.occupied(i0)) return false; // Pauli block
        const auto N_below = d.raw().popcount_below(i0);
        sign = (N_below % 2 == 0) ? +1 : -1;
    }
    return true;
}

// Same-spin excitation: sign is (-1)^C where C is the number of electrons
// strictly between i and j.
inline int8_t same_spin_excitation_sign(const SpinDeterminant& d, size_t i0, size_t j0) {
    size_t p_min = std::min(i0, j0);
    size_t p_max = std::max(i0, j0);
    // popcount_below(p_max) counts set bits in [0, p_max-1]
    // popcount_below(p_min + 1) counts set bits in [0, p_min]
    // The difference is the number of set bits in [p_min+1, p_max-1]
    const auto crossings = d.raw().popcount_below(p_max) - d.raw().popcount_below(p_min + 1);
    return (crossings % 2 == 0) ? +1 : -1;
}

bool SlaterDeterminant::apply_excitation_single_fast(
    const SlaterDeterminant& s, size_t i0, size_t j0,
    Spin spin_i, Spin spin_j, SlaterDeterminant& out, int8_t& sign,
    SpinOrbitalOrder order) noexcept
{
    if (i0 >= s.n_spatial_ || j0 >= s.n_spatial_) return false;

    // Case 1: Same spin sectors (e.g., c_iα† c_jα)
    if (spin_i == spin_j) {
        if (i0 == j0) { // Number operator: c_i† c_i
            const auto& d = (spin_i == Spin::Alpha) ? s.alpha_ : s.beta_;
            if (!d.occupied(i0)) return false;
            out = s;
            sign = 1;
            return true;
        }
        const auto& d_in = (spin_i == Spin::Alpha) ? s.alpha_ : s.beta_;
        if (!d_in.occupied(j0) || d_in.occupied(i0)) return false; // Pauli
        
        sign = same_spin_excitation_sign(d_in, i0, j0);
        out = s;
        auto& d_out = (spin_i == Spin::Alpha) ? out.alpha_ : out.beta_;
        d_out.reset(j0);
        d_out.set(i0);
        return true;
    }
    // Case 2: Different spin sectors (e.g., c_iα† c_jβ)
    else {
        auto r_ann = annihilate(s, j0, spin_j, order);
        if (!r_ann) return false;
        auto r_cre = create(r_ann->det, i0, spin_i, order);
        if (!r_cre) return false;

        out = std::move(r_cre->det);
        sign = r_cre->sign * r_ann->sign;
        return true;
    }
}

bool SlaterDeterminant::apply_excitation_double_fast(
    const SlaterDeterminant& s, size_t i0, size_t j0, size_t k0, size_t l0,
    Spin spin_i, Spin spin_j, Spin spin_k, Spin spin_l,
    SlaterDeterminant& out, int8_t& sign,
    SpinOrbitalOrder order) noexcept
{
    // Apply operators right to left: k, l, j, i
    // This implementation re-uses the std::optional path for simplicity.
    // A fully optimized version would pass temporary SpinDeterminants by reference.
    auto r1 = annihilate(s, k0, spin_k, order);
    if (!r1) return false;

    auto r2 = annihilate(r1->det, l0, spin_l, order);
    if (!r2) return false;

    auto r3 = create(r2->det, j0, spin_j, order);
    if (!r3) return false;

    auto r4 = create(r3->det, i0, spin_i, order);
    if (!r4) return false;

    out = std::move(r4->det);
    sign = r4->sign * r3->sign * r2->sign * r1->sign;
    return true;
}

// ================================ Wavefunction ===============================

Wavefunction::Wavefunction(std::size_t n_spatial) : n_spatial_(n_spatial) {}
Wavefunction::Wavefunction(std::size_t n_spatial, const Data& init)
    : n_spatial_(n_spatial), data_(init) {}

std::size_t Wavefunction::num_spatial_orbitals() const noexcept { return n_spatial_; }
const Wavefunction::Data& Wavefunction::data() const noexcept { return data_; }

void Wavefunction::add_term(const SlaterDeterminant& det, Coeff c, double tol) {
    if (std::abs(c) == 0.0) return;
    auto& v = data_[det];
    v += c;
    if (std::abs(v) < tol) data_.erase(det);
}

Wavefunction::Wavefunction(std::size_t n_spatial, 
    const std::vector<SlaterDeterminant>& basis, 
    const std::vector<Coeff>& coeffs,
    bool keep_zeros) // New parameter
    : n_spatial_(n_spatial)
{
    if (basis.size() != coeffs.size()) {
        throw std::invalid_argument("Basis and coefficients vectors must have the same size.");
    }
    data_.reserve(basis.size());

    if (keep_zeros) {
        // Direct insertion: Keep all terms, including zeros.
        for (size_t i = 0; i < basis.size(); ++i) {
            data_[basis[i]] = coeffs[i];
        }
    } else {
        // Default behavior: Prune zero-coefficient terms on creation.
        for (size_t i = 0; i < basis.size(); ++i) {
            add_term(basis[i], coeffs[i], 0);
        }
    }
}

void Wavefunction::normalize(double tol) {
    long double norm2 = 0.0L;
    for (const auto& kv : data_) norm2 += std::norm(kv.second);
    if (norm2 == 0.0L) return;
    const double norm = std::sqrt(static_cast<double>(norm2));
    for (auto& kv : data_) kv.second /= norm;
    prune(tol);
}

void Wavefunction::prune(double threshold) {
    const double t2 = threshold * threshold;
    for (auto it = data_.begin(); it != data_.end(); ) {
        if (std::norm(it->second) < t2) it = data_.erase(it);
        else ++it;
    }
}

std::vector<SlaterDeterminant> Wavefunction::basis_sorted() const {
    std::vector<SlaterDeterminant> b; b.reserve(data_.size());
    for (const auto& kv : data_) b.push_back(kv.first);
    std::sort(b.begin(), b.end());
    return b;
}

std::vector<Wavefunction::Coeff>
Wavefunction::coeffs_sorted(const std::vector<SlaterDeterminant>& basis) const {
    std::vector<Coeff> c; c.reserve(basis.size());
    for (const auto& d : basis) c.push_back(data_.at(d));
    return c;
}

Wavefunction apply_creation(const Wavefunction& wf, std::size_t i0, Spin spin,
                            SpinOrbitalOrder order)
{
    Wavefunction out(wf.num_spatial_orbitals());
    for (const auto& [det, coeff] : wf.data()) {
        auto r = SlaterDeterminant::create(det, i0, spin, order);
        if (!r) continue;
        out.add_term(r->det, coeff * static_cast<double>(r->sign));
    }
    return out;
}

Wavefunction apply_annihilation(const Wavefunction& wf, std::size_t i0, Spin spin,
                                SpinOrbitalOrder order)
{
    Wavefunction out(wf.num_spatial_orbitals());
    for (const auto& [det, coeff] : wf.data()) {
        auto r = SlaterDeterminant::annihilate(det, i0, spin, order);
        if (!r) continue;
        out.add_term(r->det, coeff * static_cast<double>(r->sign));
    }
    return out;
}


// Apply c†_i c_j
std::optional<SlaterDeterminant::OpResult>
SlaterDeterminant::apply_excitation_single(const SlaterDeterminant& s, size_t i0, size_t j0,
                                           Spin spin_i, Spin spin_j,
                                           SpinOrbitalOrder order) noexcept
{
    // Annihilate j first
    auto r_ann = annihilate(s, j0, spin_j, order);
    if (!r_ann) return std::nullopt;

    // Create i on the intermediate determinant
    auto r_cre = create(r_ann->det, i0, spin_i, order);
    if (!r_cre) return std::nullopt;
    
    // Combine signs
    r_cre->sign *= r_ann->sign;
    return r_cre;
}

// Apply c†_i c†_j c_l c_k
std::optional<SlaterDeterminant::OpResult>
SlaterDeterminant::apply_excitation_double(const SlaterDeterminant& s,
                                           size_t i0, size_t j0, size_t k0, size_t l0,
                                           Spin spin_i, Spin spin_j, Spin spin_k, Spin spin_l,
                                           SpinOrbitalOrder order) noexcept
{
    // Apply operators from right to left: c_k, c_l, c†_j, c†_i
    auto r1 = annihilate(s, k0, spin_k, order);
    if (!r1) return std::nullopt;

    auto r2 = annihilate(r1->det, l0, spin_l, order);
    if (!r2) return std::nullopt;

    auto r3 = create(r2->det, j0, spin_j, order);
    if (!r3) return std::nullopt;

    auto r4 = create(r3->det, i0, spin_i, order);
    if (!r4) return std::nullopt;

    // Combine all signs
    r4->sign = r4->sign * r3->sign * r2->sign * r1->sign;
    return r4;
}

Wavefunction::Coeff Wavefunction::dot(const Wavefunction& other) const {
    if (n_spatial_ != other.n_spatial_) {
        throw std::invalid_argument("Wavefunctions must have the same number of spatial orbitals for dot product.");
    }

    Coeff result = {0.0, 0.0};
    // Iterate over the smaller of the two maps for efficiency
    const auto& map_a = (data_.size() < other.data_.size()) ? data_ : other.data_;
    const auto& map_b = (data_.size() < other.data_.size()) ? other.data_ : data_;

    for (const auto& [det, coeff_a] : map_a) {
        auto it = map_b.find(det);
        if (it != map_b.end()) {
            const auto& coeff_b = it->second;
            result += std::conj(coeff_a) * coeff_b;
        }
    }
    return result;
}

void Wavefunction::add_wavefunction(const Wavefunction& other, Coeff scale) {
    if (n_spatial_ != other.n_spatial_) {
        throw std::invalid_argument("Wavefunctions must have the same number of spatial orbitals for addition.");
    }
    for (const auto& [det, coeff] : other.data_) {
        add_term(det, coeff * scale);
    }
}


// ====================== Wavefunction Operator Application =======================

// --- Helper for bucketing ---
// Key for one-body term: packs (j, spin_j)
inline uint64_t make_key1(size_t j, Spin spin_j) {
    return (static_cast<uint64_t>(j) << 1) | static_cast<uint64_t>(spin_j);
}

// Key for two-body term: packs (k, l, spin_k, spin_l)
inline uint64_t make_key2(size_t k, size_t l, Spin spin_k, Spin spin_l) {
    // Ensure canonical order (k, sk) <= (l, sl) to halve bucket search space for some cases
    size_t p1 = k; Spin s1 = spin_k;
    size_t p2 = l; Spin s2 = spin_l;
    if (p1 > p2 || (p1 == p2 && static_cast<uint8_t>(s1) > static_cast<uint8_t>(s2))) {
        std::swap(p1, p2);
        std::swap(s1, s2);
    }
    return (static_cast<uint64_t>(p1) << 32) |
           (static_cast<uint64_t>(p2) << 2)  |
           (static_cast<uint64_t>(s1) << 1)  |
           static_cast<uint64_t>(s2);
}


Wavefunction apply_one_body_operator_(const Wavefunction& wf,
                                     const std::vector<OneBodyTerm>& terms)
{
    Wavefunction out(wf.num_spatial_orbitals());
    if (wf.data().empty()) return out;

    // 1. Build buckets of terms based on annihilated orbital (j, spin_j)
    std::unordered_map<uint64_t, std::vector<const OneBodyTerm*>> buckets;
    for (const auto& term : terms) {
        if (std::abs(term.value) > 0.0) { // Simple screening
            buckets[make_key1(term.j, term.spin_j)].push_back(&term);
        }
    }

    // 2. Iterate through determinants in the wavefunction
    SlaterDeterminant excited_det(wf.num_spatial_orbitals());
    int8_t sign;

    for (const auto& [det, coeff] : wf.data()) {
        // 3. For each determinant, check its occupied alpha orbitals
        for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) {
            const size_t j = static_cast<size_t>(*it);
            auto bucket_it = buckets.find(make_key1(j, Spin::Alpha));
            if (bucket_it != buckets.end()) {
                // 4. If a bucket exists, apply all excitations from it
                for (const auto* term : bucket_it->second) {
                    if (SlaterDeterminant::apply_excitation_single_fast(det, term->i, term->j, term->spin_i, term->spin_j, excited_det, sign)) {
                        out.add_term(excited_det, coeff * term->value * static_cast<double>(sign));
                    }
                }
            }
        }
        // 5. Repeat for beta orbitals
        for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it) {
            const size_t j = static_cast<size_t>(*it);
            auto bucket_it = buckets.find(make_key1(j, Spin::Beta));
            if (bucket_it != buckets.end()) {
                for (const auto* term : bucket_it->second) {
                    if (SlaterDeterminant::apply_excitation_single_fast(det, term->i, term->j, term->spin_i, term->spin_j, excited_det, sign)) {
                        out.add_term(excited_det, coeff * term->value * static_cast<double>(sign));
                    }
                }
            }
        }
    }
    return out;
}

Wavefunction apply_two_body_operator_(const Wavefunction& wf,
                                     const std::vector<TwoBodyTerm>& terms)
{
    Wavefunction out(wf.num_spatial_orbitals());
    if (wf.data().empty()) return out;

    // 1. Build buckets for two-body terms
    std::unordered_map<uint64_t, std::vector<const TwoBodyTerm*>> buckets;
    for (const auto& term : terms) {
        if (std::abs(term.value) > 0.0) {
            buckets[make_key2(term.k, term.l, term.spin_k, term.spin_l)].push_back(&term);
        }
    }

    // 2. Iterate through determinants
    SlaterDeterminant excited_det(wf.num_spatial_orbitals());
    int8_t sign;
    std::vector<std::pair<size_t, Spin>> occupied_orbs;

    for (const auto& [det, coeff] : wf.data()) {
        // Collect all occupied spin-orbitals for easier iteration over pairs
        occupied_orbs.clear();
        for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) occupied_orbs.emplace_back(static_cast<size_t>(*it), Spin::Alpha);
        for (auto it = det.beta().begin_occ();  it != det.beta().end_occ();  ++it) occupied_orbs.emplace_back(static_cast<size_t>(*it), Spin::Beta);

        // 3. Iterate over all PAIRS of occupied orbitals (k, sk) and (l, sl)
        for (size_t idx1 = 0; idx1 < occupied_orbs.size(); ++idx1) {
            for (size_t idx2 = idx1 + 1; idx2 < occupied_orbs.size(); ++idx2) {
                const auto& [k, sk] = occupied_orbs[idx1];
                const auto& [l, sl] = occupied_orbs[idx2];
                
                auto bucket_it = buckets.find(make_key2(k, l, sk, sl));
                if (bucket_it != buckets.end()) {
                    for (const auto* term : bucket_it->second) {
                        // The key is canonical, but the term may not be. Check both permutations.
                        if ((term->k == k && term->l == l && term->spin_k == sk && term->spin_l == sl) ||
                            (term->k == l && term->l == k && term->spin_k == sl && term->spin_l == sk)) {
                            if (SlaterDeterminant::apply_excitation_double_fast(det, term->i, term->j, term->k, term->l, term->spin_i, term->spin_j, term->spin_k, term->spin_l, excited_det, sign)) {
                                out.add_term(excited_det, coeff * term->value * static_cast<double>(sign));
                            }
                        }
                    }
                }
            }
        }
    }
    return out;
}


// Hash & Eq already defined for SlaterDeterminant in your code
using Coeff = Wavefunction::Coeff;
using Map   = std::unordered_map<SlaterDeterminant, Coeff>;

static inline std::size_t shard_of(const SlaterDeterminant& d, std::size_t S) {
    std::size_t h = std::hash<SlaterDeterminant>{}(d);
    return h & (S - 1); // S must be power of two
}

Wavefunction apply_one_body_operator(const Wavefunction& wf,
                                     const std::vector<OneBodyTerm>& terms)
{
    Wavefunction out(wf.num_spatial_orbitals());
    if (wf.data().empty()) return out;
    const std::size_t M = wf.num_spatial_orbitals();

    // Buckets (read-only)
    std::unordered_map<uint64_t, std::vector<const OneBodyTerm*>> buckets;
    buckets.reserve(terms.size());
    for (const auto& t : terms) if (std::abs(t.value) > 0.0)
        buckets[make_key1(t.j, t.spin_j)].push_back(&t);

    // Flatten wf for parallel iteration
    std::vector<std::pair<SlaterDeterminant, Coeff>> items;
    items.reserve(wf.data().size());
    for (const auto& kv : wf.data()) items.emplace_back(kv.first, kv.second);

    // Local per-thread maps (sums duplicates early)
    int T = 1;
#ifdef _OPENMP
    T = std::max(1, omp_get_max_threads());
#endif
    std::vector<Map> local_maps(T);

    // Generate + accumulate locally
#ifdef _OPENMP
    #pragma omp parallel
#endif
    {
        int tid = 0;
#ifdef _OPENMP
        tid = omp_get_thread_num();
#endif
        auto& acc = local_maps[tid];
        acc.reserve(std::max<std::size_t>(512, items.size()/T));

        SlaterDeterminant excited(M);
        int8_t sign;

#ifdef _OPENMP
        #pragma omp for schedule(static)
#endif
        for (std::ptrdiff_t idx = 0; idx < (std::ptrdiff_t)items.size(); ++idx) {
            const auto& det   = items[(std::size_t)idx].first;
            const auto& coeff = items[(std::size_t)idx].second;

            // α
            for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) {
                const size_t j = (size_t)*it;
                auto bi = buckets.find(make_key1(j, Spin::Alpha));
                if (bi == buckets.end()) continue;
                for (const auto* t : bi->second) {
                    if (SlaterDeterminant::apply_excitation_single_fast(det, t->i, t->j, t->spin_i, t->spin_j,
                                                                        excited, sign)) {
                        acc[excited] += coeff * t->value * double(sign);
                    }
                }
            }
            // β
            for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it) {
                const size_t j = (size_t)*it;
                auto bi = buckets.find(make_key1(j, Spin::Beta));
                if (bi == buckets.end()) continue;
                for (const auto* t : bi->second) {
                    if (SlaterDeterminant::apply_excitation_single_fast(det, t->i, t->j, t->spin_i, t->spin_j,
                                                                        excited, sign)) {
                        acc[excited] += coeff * t->value * double(sign);
                    }
                }
            }
        }
    }

    // Sharded global reduce to avoid a single hot hash map
    // Choose power-of-two shard count (e.g. next power of two >= 2*T)
    std::size_t S = 1;
    while (S < (std::size_t)(2 * T)) S <<= 1;
    std::vector<Map> shards(S);

#ifdef _OPENMP
    #pragma omp parallel for schedule(guided)
#endif
    for (int t = 0; t < T; ++t) {
        for (const auto& kv : local_maps[t]) {
            const auto& det = kv.first;
            auto s = shard_of(det, S);
            // To avoid locks, move per-thread into a thread-local buffer first,
            // then we do a second parallel pass to combine shard-by-shard:
#ifdef _OPENMP
            #pragma omp critical  // cheap: S is large; contention low
#endif
            shards[s][det] += kv.second;
        }
    }

    // Finalize Wavefunction
    for (auto& sh : shards)
        for (auto& kv : sh)
            out.add_term(kv.first, kv.second);

    return out;
}

// In the .cpp that defines this, make sure you have:
//   #include <omp.h>
// and you link OpenMP in CMake (you already do).

Wavefunction apply_two_body_operator(const Wavefunction& wf,
                                     const std::vector<TwoBodyTerm>& terms)
{
    using Coeff = Wavefunction::Coeff;

    Wavefunction out(wf.num_spatial_orbitals());
    if (wf.data().empty() || terms.empty()) return out;
    const std::size_t M = wf.num_spatial_orbitals();

    // 1) Read-only buckets keyed by canonical annihilated pair (k,sk),(l,sl)
    std::unordered_map<uint64_t, std::vector<const TwoBodyTerm*>> buckets;
    buckets.reserve(terms.size());
    for (const auto& term : terms) {
        if (std::abs(term.value) > 0.0) {
            buckets[make_key2(term.k, term.l, term.spin_k, term.spin_l)].push_back(&term);
        }
    }

    // 2) Flatten wf for parallel iteration
    std::vector<std::pair<SlaterDeterminant, Coeff>> items;
    items.reserve(wf.data().size());
    for (const auto& kv : wf.data()) items.emplace_back(kv.first, kv.second);

    // 3) Per-thread accumulation maps: SlaterDeterminant -> summed Coeff
    using Map = std::unordered_map<SlaterDeterminant, Coeff>;
    int T = 1;
#ifdef _OPENMP
    T = std::max(1, omp_get_max_threads());
#endif
    std::vector<Map> local_maps((std::size_t)T);

#ifdef _OPENMP
    #pragma omp parallel
#endif
    {
        int tid = 0;
#ifdef _OPENMP
        tid = omp_get_thread_num();
#endif
        auto& acc = local_maps[(std::size_t)tid];
        acc.reserve(std::max<std::size_t>(512, items.size() / std::max(1, T)));

        SlaterDeterminant excited_det(M);
        int8_t sign;

        std::vector<std::pair<size_t, Spin>> occ;
        occ.reserve(2 * M);

#ifdef _OPENMP
        #pragma omp for schedule(guided)
#endif
        for (std::ptrdiff_t idx = 0; idx < static_cast<std::ptrdiff_t>(items.size()); ++idx) {
            const auto& det   = items[(std::size_t)idx].first;
            const auto& coeff = items[(std::size_t)idx].second;

            // Collect occupied spin-orbitals
            occ.clear();
            for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it)
                occ.emplace_back(static_cast<size_t>(*it), Spin::Alpha);
            for (auto it = det.beta().begin_occ();  it != det.beta().end_occ();  ++it)
                occ.emplace_back(static_cast<size_t>(*it), Spin::Beta);

            const std::size_t L = occ.size();
            for (std::size_t a = 0; a + 1 < L; ++a) {
                const auto [k, sk] = occ[a];
                for (std::size_t b = a + 1; b < L; ++b) {
                    const auto [l, sl] = occ[b];

                    auto itB = buckets.find(make_key2(k, l, sk, sl));
                    if (itB == buckets.end()) continue;

                    // Apply all matching two-body terms from the bucket
                    for (const auto* term : itB->second) {
                        const bool match_kl = (term->k == k && term->l == l &&
                                               term->spin_k == sk && term->spin_l == sl);
                        const bool match_lk = (term->k == l && term->l == k &&
                                               term->spin_k == sl && term->spin_l == sk);
                        if (!(match_kl || match_lk)) continue;

                        if (SlaterDeterminant::apply_excitation_double_fast(
                                det, term->i, term->j, term->k, term->l,
                                term->spin_i, term->spin_j, term->spin_k, term->spin_l,
                                excited_det, sign))
                        {
                            acc[excited_det] += coeff * term->value * static_cast<double>(sign);
                        }
                    }
                }
            }
        } // omp for
    } // omp parallel

    // 4) Lock-free sharded merge of the local maps into S shards
    auto shard_of = [](const SlaterDeterminant& d, std::size_t S)->std::size_t {
        std::size_t h = std::hash<SlaterDeterminant>{}(d);
        return h & (S - 1); // S must be a power of two
    };

    std::size_t S = 1;
    while (S < (std::size_t)(2 * T)) S <<= 1; // at least 2*T shards
    std::vector<Map> shards(S);

#ifdef _OPENMP
    #pragma omp parallel for schedule(static)
#endif
    for (int s = 0; s < (int)S; ++s) {
        auto& dst = shards[(std::size_t)s];
        // Rough capacity hint: distribute keys evenly
        std::size_t hint = 0;
        for (const auto& lm : local_maps) hint += lm.size();
        hint = hint / S + 8;
        dst.reserve(hint);

        for (const auto& lm : local_maps) {
            for (const auto& kv : lm) {
                if ((int)shard_of(kv.first, S) == s) {
                    dst[kv.first] += kv.second;
                }
            }
        }
    }

    // 5) Emit to output wavefunction
    for (auto& sh : shards)
        for (auto& kv : sh)
            out.add_term(kv.first, kv.second);

    return out;
}

// ============================ Connectivity Generation ===========================

std::vector<SlaterDeterminant>
get_connections_one_body_(const std::vector<SlaterDeterminant>& basis,
                         const std::vector<OneBodyTerm>& terms)
{
    std::unordered_set<SlaterDeterminant> unique_dets;
    if (basis.empty()) return {};

    const size_t n_spatial = basis[0].num_spatial_orbitals();
    std::unordered_map<uint64_t, std::vector<const OneBodyTerm*>> buckets;
    for (const auto& term : terms) {
        if (std::abs(term.value) > 0.0) {
            buckets[make_key1(term.j, term.spin_j)].push_back(&term);
        }
    }

    SlaterDeterminant excited_det(n_spatial);
    int8_t sign;

    for (const auto& det : basis) {
        // Alpha
        for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) {
            const size_t j = static_cast<size_t>(*it);
            auto bucket_it = buckets.find(make_key1(j, Spin::Alpha));
            if (bucket_it != buckets.end()) {
                for (const auto* term : bucket_it->second) {
                    if (SlaterDeterminant::apply_excitation_single_fast(det, term->i, term->j, term->spin_i, term->spin_j, excited_det, sign)) {
                        unique_dets.insert(excited_det);
                    }
                }
            }
        }
        // Beta
        for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it) {
            const size_t j = static_cast<size_t>(*it);
            auto bucket_it = buckets.find(make_key1(j, Spin::Beta));
            if (bucket_it != buckets.end()) {
                for (const auto* term : bucket_it->second) {
                    if (SlaterDeterminant::apply_excitation_single_fast(det, term->i, term->j, term->spin_i, term->spin_j, excited_det, sign)) {
                        unique_dets.insert(excited_det);
                    }
                }
            }
        }
    }

    std::vector<SlaterDeterminant> connected_dets(unique_dets.begin(), unique_dets.end());
    std::sort(connected_dets.begin(), connected_dets.end());
    return connected_dets;
}
                         
std::vector<SlaterDeterminant>
get_connections_two_body_(const std::vector<SlaterDeterminant>& basis,
                         const std::vector<TwoBodyTerm>& terms)
{
    // 1. Handle edge cases
    if (basis.empty() || terms.empty()) {
        return {};
    }

    // 2. Use a hash set for efficient collection of unique determinants
    std::unordered_set<SlaterDeterminant> unique_dets;
    const size_t n_spatial = basis[0].num_spatial_orbitals();

    // 3. Build buckets of terms based on the CANONICAL annihilated pair (k, sk), (l, sl)
    //    This drastically prunes the search space.
    std::unordered_map<uint64_t, std::vector<const TwoBodyTerm*>> buckets;
    for (const auto& term : terms) {
        if (std::abs(term.value) > 0.0) {
            buckets[make_key2(term.k, term.l, term.spin_k, term.spin_l)].push_back(&term);
        }
    }

    // 4. Pre-allocate objects to avoid re-allocation inside the tight loops
    SlaterDeterminant excited_det(n_spatial);
    int8_t sign;
    std::vector<std::pair<size_t, Spin>> occupied_orbs;
    occupied_orbs.reserve(n_spatial * 2);

    // 5. Iterate through each determinant in the starting basis
    for (const auto& det : basis) {
        // Create a flat list of occupied spin-orbitals for easy iteration over pairs
        occupied_orbs.clear();
        for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) {
            occupied_orbs.emplace_back(static_cast<size_t>(*it), Spin::Alpha);
        }
        for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it) {
            occupied_orbs.emplace_back(static_cast<size_t>(*it), Spin::Beta);
        }

        // 6. Iterate over all unique PAIRS of occupied orbitals { (k, sk), (l, sl) }
        for (size_t idx1 = 0; idx1 < occupied_orbs.size(); ++idx1) {
            for (size_t idx2 = idx1 + 1; idx2 < occupied_orbs.size(); ++idx2) {
                const auto& [k, sk] = occupied_orbs[idx1];
                const auto& [l, sl] = occupied_orbs[idx2];

                // 7. Find the corresponding bucket for this annihilated pair
                auto bucket_it = buckets.find(make_key2(k, l, sk, sl));
                if (bucket_it != buckets.end()) {
                    
                    // 8. Apply all operator terms from the bucket
                    for (const auto* term : bucket_it->second) {
                        // The bucket key is canonical, but the term itself may be stored as v_ijkl or v_ijlk.
                        // We must ensure the term we apply matches the orbitals we're annihilating.
                        bool term_matches_kl = (term->k == k && term->l == l && term->spin_k == sk && term->spin_l == sl);
                        bool term_matches_lk = (term->k == l && term->l == k && term->spin_k == sl && term->spin_l == sk);
                        
                        if (term_matches_kl || term_matches_lk) {
                            // Apply the excitation operator c†_i c†_j c_l c_k
                            if (SlaterDeterminant::apply_excitation_double_fast(det,
                                                             term->i, term->j, term->k, term->l,
                                                             term->spin_i, term->spin_j, term->spin_k, term->spin_l,
                                                             excited_det, sign))
                            {
                                // If successful, add the new determinant to our set
                                unique_dets.insert(excited_det);
                            }
                        }
                    }
                }
            }
        }
    }

    // 9. Convert the set to a sorted vector and return
    std::vector<SlaterDeterminant> connected_dets(unique_dets.begin(), unique_dets.end());
    std::sort(connected_dets.begin(), connected_dets.end());
    return connected_dets;
}

std::vector<SlaterDeterminant>
get_connections_one_body(const std::vector<SlaterDeterminant>& basis,
                         const std::vector<OneBodyTerm>& terms)
{
    if (basis.empty()) return {};

    const size_t n_spatial = basis[0].num_spatial_orbitals();

    // Build read-only buckets once
    std::unordered_map<uint64_t, std::vector<const OneBodyTerm*>> buckets;
    buckets.reserve(terms.size());
    for (const auto& term : terms) {
        if (std::abs(term.value) > 0.0) {
            buckets[make_key1(term.j, term.spin_j)].push_back(&term);
        }
    }

    // Thread-local accumulation of unique dets; gathered after parallel region
    std::vector<std::unordered_set<SlaterDeterminant>> partials;
    partials.reserve(omp_get_max_threads());

    #pragma omp parallel
    {
        std::unordered_set<SlaterDeterminant> local;
        // Rough reserve to reduce rehashing
        local.reserve(std::max<size_t>(16, basis.size() / std::max(1, omp_get_num_threads())));

        SlaterDeterminant excited_det(n_spatial);
        int8_t sign;

        #pragma omp for schedule(guided)
        for (std::ptrdiff_t idx = 0; idx < static_cast<std::ptrdiff_t>(basis.size()); ++idx) {
            const auto& det = basis[static_cast<size_t>(idx)];

            // Alpha occupied orbitals
            for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) {
                const size_t j = static_cast<size_t>(*it);
                auto key = make_key1(j, Spin::Alpha);
                auto b = buckets.find(key);
                if (b != buckets.end()) {
                    for (const auto* term : b->second) {
                        if (SlaterDeterminant::apply_excitation_single_fast(
                                det, term->i, term->j, term->spin_i, term->spin_j,
                                excited_det, sign))
                        {
                            local.insert(excited_det);
                        }
                    }
                }
            }
            // Beta occupied orbitals
            for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it) {
                const size_t j = static_cast<size_t>(*it);
                auto key = make_key1(j, Spin::Beta);
                auto b = buckets.find(key);
                if (b != buckets.end()) {
                    for (const auto* term : b->second) {
                        if (SlaterDeterminant::apply_excitation_single_fast(
                                det, term->i, term->j, term->spin_i, term->spin_j,
                                excited_det, sign))
                        {
                            local.insert(excited_det);
                        }
                    }
                }
            }
        }

        #pragma omp critical
        {
            partials.push_back(std::move(local));
        }
    }

    // Merge thread-local sets
    std::unordered_set<SlaterDeterminant> unique_dets;
    size_t hint = 0; for (auto& s : partials) hint += s.size();
    unique_dets.reserve(hint);
    for (auto& s : partials) {
        unique_dets.insert(s.begin(), s.end());
    }

    std::vector<SlaterDeterminant> connected_dets(unique_dets.begin(), unique_dets.end());
    std::sort(connected_dets.begin(), connected_dets.end());
    return connected_dets;
}

// Requires: #include <omp.h>

std::vector<SlaterDeterminant>
get_connections_two_body(const std::vector<SlaterDeterminant>& basis,
                         const std::vector<TwoBodyTerm>& terms)
{
    if (basis.empty() || terms.empty()) return {};

    const size_t n_spatial = basis[0].num_spatial_orbitals();

    // Read-only buckets keyed by canonical annihilated pair (k,sk),(l,sl)
    std::unordered_map<uint64_t, std::vector<const TwoBodyTerm*>> buckets;
    buckets.reserve(terms.size());
    for (const auto& term : terms) {
        if (std::abs(term.value) > 0.0) {
            buckets[make_key2(term.k, term.l, term.spin_k, term.spin_l)].push_back(&term);
        }
    }

    // Thread-local accumulation
    std::vector<std::unordered_set<SlaterDeterminant>> partials;
    partials.reserve(omp_get_max_threads());

    #pragma omp parallel
    {
        std::unordered_set<SlaterDeterminant> local;
        local.reserve(std::max<size_t>(16, basis.size() / std::max(1, omp_get_num_threads())));

        SlaterDeterminant excited_det(n_spatial);
        int8_t sign;

        // Per-thread scratch
        std::vector<std::pair<size_t, Spin>> occupied_orbs;
        occupied_orbs.reserve(n_spatial * 2);

        #pragma omp for schedule(guided)
        for (std::ptrdiff_t idx = 0; idx < static_cast<std::ptrdiff_t>(basis.size()); ++idx) {
            const auto& det = basis[static_cast<size_t>(idx)];

            occupied_orbs.clear();
            for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it)
                occupied_orbs.emplace_back(static_cast<size_t>(*it), Spin::Alpha);
            for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it)
                occupied_orbs.emplace_back(static_cast<size_t>(*it), Spin::Beta);

            const size_t L = occupied_orbs.size();
            for (size_t a = 0; a + 1 < L; ++a) {
                const auto [k, sk] = occupied_orbs[a];
                for (size_t b = a + 1; b < L; ++b) {
                    const auto [l, sl] = occupied_orbs[b];

                    auto key = make_key2(k, l, sk, sl);
                    auto bkt = buckets.find(key);
                    if (bkt == buckets.end()) continue;

                    for (const auto* term : bkt->second) {
                        // ensure the term orientation matches the occupied pair
                        const bool match_kl = (term->k == k && term->l == l &&
                                               term->spin_k == sk && term->spin_l == sl);
                        const bool match_lk = (term->k == l && term->l == k &&
                                               term->spin_k == sl && term->spin_l == sk);
                        if (!(match_kl || match_lk)) continue;

                        if (SlaterDeterminant::apply_excitation_double_fast(
                                det, term->i, term->j, term->k, term->l,
                                term->spin_i, term->spin_j, term->spin_k, term->spin_l,
                                excited_det, sign))
                        {
                            local.insert(excited_det);
                        }
                    }
                }
            }
        }

        #pragma omp critical
        {
            partials.push_back(std::move(local));
        }
    }

    // Merge thread-local sets
    std::unordered_set<SlaterDeterminant> unique_dets;
    size_t hint = 0; for (auto& s : partials) hint += s.size();
    unique_dets.reserve(hint);
    for (auto& s : partials) {
        unique_dets.insert(s.begin(), s.end());
    }

    std::vector<SlaterDeterminant> connected_dets(unique_dets.begin(), unique_dets.end());
    std::sort(connected_dets.begin(), connected_dets.end());
    return connected_dets;
}



} // namespace ci

// ============================== Hashing ======================================

namespace {
inline std::size_t hash_mix_u64(std::size_t seed, ci::u64 v) noexcept {
    // splitmix64-ish mix, then combine
    v ^= v >> 30; v *= 0xbf58476d1ce4e5b9ULL;
    v ^= v >> 27; v *= 0x94d049bb133111ebULL;
    v ^= v >> 31;
    return seed ^ (static_cast<std::size_t>(v) + 0x9e3779b97f4a7c15ULL + (seed<<6) + (seed>>2));
}
}

std::size_t std::hash<ci::BitsetVec>::operator()(const ci::BitsetVec& b) const noexcept {
    // Start with a hash of the size, then mix in the words.
    std::size_t seed = std::hash<std::size_t>{}(b.size());
    for (auto w : b.words()) {
        seed = hash_mix_u64(seed, w);
    }
    return seed;
}

std::size_t std::hash<ci::Determinant>::operator()(const ci::Determinant& d) const noexcept {
    std::size_t seed = d.num_orbitals();
    for (auto w : d.bits().words()) seed = hash_mix_u64(seed, w);
    return seed;
}


std::size_t std::hash<ci::SpinDeterminant>::operator()(const ci::SpinDeterminant& sd) const noexcept {
    // This now correctly depends on ALL data within the bitset.
    return std::hash<ci::BitsetVec>{}(sd.raw());
}

std::size_t std::hash<ci::SlaterDeterminant>::operator()(const ci::SlaterDeterminant& s) const noexcept {
    std::size_t h_alpha = std::hash<ci::SpinDeterminant>{}(s.alpha());
    std::size_t h_beta  = std::hash<ci::SpinDeterminant>{}(s.beta());
    // Combine them. The way you do it is a standard technique.
    return h_alpha ^ (h_beta + 0x9e3779b97f4a7c15ULL + (h_alpha << 6) + (h_alpha >> 2));
}


// ---------------------------------------------------------// slater_condon.cpp
#include "slater_condon.h"
#include <bit>      // std::popcount
#include <algorithm>

namespace ci {

// ----- helpers -----

static inline std::size_t popcount_between_exclusive(const BitsetVec& b,
                                                     int x, int y) noexcept {
    // count set bits in (min, max) exclusive => [min+1, max)
    int lo = std::min(x, y);
    int hi = std::max(x, y);
    if (hi - lo <= 1) return 0;
    // popcount in [0, hi) minus popcount in [0, lo+1)
    return b.popcount_below(static_cast<std::size_t>(hi))
         - b.popcount_below(static_cast<std::size_t>(lo + 1));
}

int parity_single(const Determinant& I, int a, int r) noexcept {
    const auto& bits = I.bits();
    const std::size_t c = popcount_between_exclusive(bits, a, r);
    return static_cast<int>(c & 1u);
}

int parity_double(const Determinant& I, int a, int r, int b, int s) noexcept {
    const auto& bits = I.bits();

    // First move (a -> r)
    int p1 = parity_single(I, a, r);

    // For the second move (b -> s), the intermediate state differs at a,r only.
    // Count occ strictly between (b,s) on I, then correct for (a,r) if they lie inside.
    int lo = std::min(b, s);
    int hi = std::max(b, s);

    std::size_t base = popcount_between_exclusive(bits, b, s);

    // a: 1 -> 0 in the intermediate
    if (hi - lo > 1 && a > lo && a < hi) {
        // Only subtract if a was occupied in I (it is, for a->r to be valid)
        base = (base > 0) ? (base - 1) : 0;
    }
    // r: 0 -> 1 in the intermediate
    if (hi - lo > 1 && r > lo && r < hi) {
        base += 1;
    }

    int p2 = static_cast<int>(base & 1u);
    return (p1 + p2) & 1;
}

// --------------------------- Slater–Condon kernels ---------------------------

cx OO(const H1View& H, const ERIView& V, const std::vector<int>& occK) noexcept {
    // e1 = sum H[i,i]
    cx e1 = cx{0.0, 0.0};
    for (int i : occK) e1 += H(static_cast<std::size_t>(i), static_cast<std::size_t>(i));

    // e2 = sum over i,j ( (ij|ij) - (ij|ji) )
    cx e2 = cx{0.0, 0.0};
    const std::size_t n = occK.size();
    for (std::size_t a = 0; a < n; ++a) {
        const int i = occK[a];
        for (std::size_t b = 0; b < n; ++b) {
            const int j = occK[b];
            e2 += V(i,j,i,j) - V(i,j,j,i);
        }
    }
    return e1 + e2 * 0.5; // divide by 2 as in Julia OO
}

cx OS(const H1View& H, const ERIView& V, int a, int r,
      const std::vector<int>& occK) noexcept
{
    // e1 = H[a,r]
    cx e1 = H(static_cast<std::size_t>(a), static_cast<std::size_t>(r));

    // e2 = sum_i ( (a i | r i) - (a i | i r) )
    cx e2 = cx{0.0, 0.0};
    for (int i : occK) {
        e2 += V(a,i,r,i) - V(a,i,i,r);
    }
    return e1 + e2;
}

cx OD(const ERIView& V, int m, int n, int p, int q) noexcept {
    // (mn|pq) - (mn|qp)
    return V(m,n,p,q) - V(m,n,q,p);
}

// ------------------------------ KL dispatcher --------------------------------

static inline int hamming(const Determinant& A, const Determinant& B) noexcept {
    const auto& wa = A.bits().words();
    const auto& wb = B.bits().words();
    const std::size_t nw = wa.size();
    std::size_t c = 0;
    for (std::size_t w = 0; w < nw; ++w) c += std::popcount(wa[w] ^ wb[w]);
    return static_cast<int>(c);
}

static inline void differing_positions(const Determinant& D1, const Determinant& D2,
                                       std::vector<int>& from_D1, std::vector<int>& from_D2)
{
    from_D1.clear(); from_D2.clear();
    const auto& wa = D1.bits().words();
    const auto& wb = D2.bits().words();
    const std::size_t nw = wa.size();
    for (std::size_t w = 0; w < nw; ++w) {
        std::uint64_t x = wa[w] ^ wb[w];
        while (x) {
            unsigned tz = std::countr_zero(x);
            int bit = static_cast<int>(w*64 + tz);
            bool in1 = ((wa[w] >> tz) & 1ull) != 0ull;
            if (in1) from_D1.push_back(bit);
            else     from_D2.push_back(bit);
            x &= (x - 1); // clear lowest set bit
        }
    }
    // Preserve low-to-high discovery order to match your Julia diffbit behavior
    std::sort(from_D1.begin(), from_D1.end());
    std::sort(from_D2.begin(), from_D2.end());
}

static inline void occ_list(const Determinant& D, std::vector<int>& occK_out) {
    occK_out.clear();
    for (auto it = D.begin_occ(); it != D.end_occ(); ++it)
        occK_out.push_back(*it);
}

cx KL(const Determinant& D1, const Determinant& D2,
      const H1View& H, const ERIView& V) noexcept
{
    const int ham = hamming(D1, D2);
    if (ham == 0) {
        std::vector<int> occK;
        occ_list(D1, occK);
        return OO(H, V, occK);
    }

    std::vector<int> from1, from2;
    differing_positions(D1, D2, from1, from2);

    if (ham == 2) {
        // Single excitation: from1 = {a}, from2 = {r}
        if (from1.size() != 1 || from2.size() != 1) return cx{0.0, 0.0};
        int a = from1[0], r = from2[0];
        const int p = parity_single(D1, a, r);
        std::vector<int> occK;
        occ_list(D1, occK);
        return ((p & 1) ? cx{-1.0, 0.0} : cx{1.0, 0.0}) * OS(H, V, a, r, occK);
    }

    if (ham == 4) {
        // Double excitation: from1 = {m,n}, from2 = {p,q}
        if (from1.size() != 2 || from2.size() != 2) return cx{0.0, 0.0};
        int m = from1[0], n = from1[1];
        int p = from2[0], q = from2[1];
        const int s = parity_double(D1, m, p, n, q); // matches Julia's get_p1p2 order
        return ((s & 1) ? cx{-1.0, 0.0} : cx{1.0, 0.0}) * OD(V, m, n, p, q);
    }

    return cx{0.0, 0.0};
}

} // namespace ci// hamiltonian.cpp
#include "hamiltonian.h"

#include <bit>
#include <algorithm>
#include <numeric>
#include <tuple>
#include <unordered_set>
#include <cassert>

// Note: We keep AlphaFirst ordering consistently.

namespace ci {

// -------------------------- utilities: hashing & keys ------------------------

struct SDPairHash {
    std::size_t operator()(const SlaterDeterminant& s) const noexcept {
        return std::hash<SlaterDeterminant>{}(s);
    }
};

struct SDPairEq {
    bool operator()(const SlaterDeterminant& a, const SlaterDeterminant& b) const noexcept {
        return a == b;
    }
};

// Build combined determinant (K=2M) directly from α/β sets (faster than interleave()).
static inline void occ_list_alpha_beta(const SlaterDeterminant& sd, std::vector<int>& occK) {
    occK.clear();
    const std::size_t M = sd.num_spatial_orbitals();
    for (auto it = sd.alpha().begin_occ(); it != sd.alpha().end_occ(); ++it) {
        occK.push_back(*it);
    }
    for (auto it = sd.beta().begin_occ(); it != sd.beta().end_occ(); ++it) {
        occK.push_back(static_cast<int>(M + *it));
    }
}

// Construct combined Determinant (K=2M) from SlaterDeterminant quickly.
static inline Determinant combined_from(const SlaterDeterminant& sd) {
    const std::size_t M = sd.num_spatial_orbitals();
    Determinant D(2*M);
    for (auto it = sd.alpha().begin_occ(); it != sd.alpha().end_occ(); ++it)
        D.set(static_cast<std::size_t>(*it));
    for (auto it = sd.beta().begin_occ(); it != sd.beta().end_occ(); ++it)
        D.set(static_cast<std::size_t>(M + *it));
    return D;
}

// XOR popcount for SpinDeterminant pair (same length).
static inline int xor_popcount(const SpinDeterminant& a, const SpinDeterminant& b) {
    const auto& wa = a.raw().words();
    const auto& wb = b.raw().words();
    std::size_t c = 0;
    for (std::size_t i = 0; i < wa.size(); ++i) c += std::popcount(wa[i] ^ wb[i]);
    return static_cast<int>(c);
}

// --------------------------- Caa / Cd / Cmag --------------------------------

struct Connections {
    // maps: key SpinDeterminant -> vector of connected SpinDeterminant
    std::unordered_map<SpinDeterminant, std::vector<SpinDeterminant>> Cs; // single
    std::unordered_map<SpinDeterminant, std::vector<SpinDeterminant>> Cd; // double
    std::unordered_map<SpinDeterminant, std::vector<SpinDeterminant>> Cmag; // magnetic
};

static Connections Caa(const std::vector<SpinDeterminant>& Ia, bool is_mag) {
    Connections res;
    res.Cs.reserve(Ia.size());
    res.Cd.reserve(Ia.size());
    res.Cmag.reserve(Ia.size());

    // Group by electron count to match your Julia condition "count_ones(ei)==count_ones(ej)"
    std::unordered_map<int, std::vector<SpinDeterminant>> byNe;
    for (const auto& e : Ia) byNe[static_cast<int>(e.count_electrons())].push_back(e);

    // Pre-fill maps
    for (const auto& e : Ia) {
        res.Cs.emplace(e, std::vector<SpinDeterminant>{});
        res.Cd.emplace(e, std::vector<SpinDeterminant>{});
        res.Cmag.emplace(e, std::vector<SpinDeterminant>{});
    }

    // Singles + doubles within fixed electron count
    for (auto& kv : byNe) {
        auto& vec = kv.second;
        const std::size_t n = vec.size();
        for (std::size_t i = 0; i < n; ++i) {
            for (std::size_t j = 0; j < n; ++j) {
                const int diff = xor_popcount(vec[i], vec[j]);
                if (diff == 2)      res.Cs[vec[i]].push_back(vec[j]);
                else if (diff == 4) res.Cd[vec[i]].push_back(vec[j]);
            }
        }
    }

    // Magnetic connections (allowed only if requested)
    if (is_mag) {
        // Compare across Ne±1 with xor popcount == 1
        for (const auto& e : Ia) {
            const int Ne = static_cast<int>(e.count_electrons());
            auto it1 = byNe.find(Ne+1);
            auto it2 = byNe.find(Ne-1);
            if (it1 != byNe.end()) {
                for (const auto& f : it1->second) {
                    if (xor_popcount(e, f) == 1) res.Cmag[e].push_back(f);
                }
            }
            if (it2 != byNe.end()) {
                for (const auto& f : it2->second) {
                    if (xor_popcount(e, f) == 1) res.Cmag[e].push_back(f);
                }
            }
        }
    }

    return res;
}

// ------------------------------ basis indexing -------------------------------

struct BasisIndex {
    // Keyed by combined Determinant; value = position in basis
    std::unordered_map<Determinant, int, std::hash<Determinant>> map;
};

static BasisIndex make_basis_index(const std::vector<SlaterDeterminant>& basis) {
    BasisIndex bi;
    bi.map.reserve(basis.size()*2);
    for (std::size_t i = 0; i < basis.size(); ++i) {
        Determinant D = combined_from(basis[i]);
        bi.map.emplace(std::move(D), static_cast<int>(i));
    }
    return bi;
}

// Build unique α/β sets from basis.
static std::pair<std::vector<SpinDeterminant>, std::vector<SpinDeterminant>>
unique_alpha_beta(const std::vector<SlaterDeterminant>& basis)
{
    std::unordered_set<SpinDeterminant> SA, SB;
    SA.reserve(basis.size()); SB.reserve(basis.size());
    for (const auto& s : basis) { SA.insert(s.alpha()); SB.insert(s.beta()); }
    return { std::vector<SpinDeterminant>(SA.begin(), SA.end()),
             std::vector<SpinDeterminant>(SB.begin(), SB.end()) };
}

// ------------------------------ COO buffer -----------------------------------

struct COO {
    std::vector<int32_t> row;
    std::vector<int32_t> col;
    std::vector<cx>      val;

    void push(int32_t r, int32_t c, cx v, double tol) {
        if (std::abs(v) < tol) return;
        row.push_back(r); col.push_back(c); val.push_back(v);
    }
};

static CSR coo_to_csr(std::size_t N, std::size_t M, COO&& coo) {
    CSR out;
    out.n_rows = N; out.n_cols = M;
    out.indptr.assign(N+1, 0);

    const std::size_t nnz = coo.val.size();
    // Count per-row
    for (std::size_t e = 0; e < nnz; ++e) {
        ++out.indptr[static_cast<std::size_t>(coo.row[e]) + 1];
    }
    // Prefix sum
    for (std::size_t i = 0; i < N; ++i) out.indptr[i+1] += out.indptr[i];

    out.indices.resize(nnz);
    out.data.resize(nnz);

    // Temporary write cursors (copy of indptr)
    std::vector<int64_t> cursor = out.indptr;

    for (std::size_t e = 0; e < nnz; ++e) {
        const int32_t r = coo.row[e];
        const int64_t pos = cursor[static_cast<std::size_t>(r)]++;
        out.indices[static_cast<std::size_t>(pos)] = coo.col[e];
        out.data   [static_cast<std::size_t>(pos)] = coo.val[e];
    }

    // (Optional) we could sort columns within each row and sum duplicates.
    // For now, algorithm produces each (i,j) at most once, mirroring Julia.

    return out;
}

// ------------------------------ main builder ---------------------------------

CSR build_hamiltonian_openmp(const std::vector<SlaterDeterminant>& basis,
                             const H1View& H, const ERIView& V,
                             bool enable_magnetic,
                             double tol)
{
    const std::size_t N = basis.size();
    if (N == 0) return CSR{};

    const std::size_t M = basis[0].num_spatial_orbitals();
    const std::size_t K = 2*M;
    (void)K; // shapes already validated by caller typically

    // Precompute unique α/β sets and connections
    auto [Ia, Ib] = unique_alpha_beta(basis);
    Connections Ca = Caa(Ia, enable_magnetic);
    Connections Cb = Caa(Ib, enable_magnetic);

    // Basis index on combined determinants
    BasisIndex BI = make_basis_index(basis);

    // Thread-local COO buffers
    const int nthreads =
    #ifdef _OPENMP
        omp_get_max_threads();
    #else
        1;
    #endif

    std::vector<COO> tl_coo(static_cast<std::size_t>(nthreads));

    // Parallel outer loop
    #pragma omp parallel for schedule(dynamic)
    for (std::int64_t irow = 0; irow < static_cast<std::int64_t>(N); ++irow) {
        const int tid =
        #ifdef _OPENMP
            omp_get_thread_num();
        #else
            0;
        #endif
        COO& coo = tl_coo[static_cast<std::size_t>(tid)];

        const SlaterDeterminant& S = basis[static_cast<std::size_t>(irow)];
        const SpinDeterminant& Sa = S.alpha();
        const SpinDeterminant& Sb = S.beta();

        // Precompute combined determinant and occ list for S
        Determinant D = combined_from(S);
        std::vector<int> occK; occ_list_alpha_beta(S, occK);

        // --- Diagonal ---
        {
            cx h = OO(H, V, occK);
            if (std::abs(h) >= tol) coo.push(static_cast<int32_t>(irow), static_cast<int32_t>(irow), h, tol);
        }

        // --- single/double alpha ---
        {
            auto it1 = Ca.Cs.find(Sa);
            auto it2 = Ca.Cd.find(Sa);
            if (it1 != Ca.Cs.end()) {
                for (const auto& ca : it1->second) {
                    SlaterDeterminant Sd(M, std::vector<int>{}, std::vector<int>{}); // scratch, but we need a real object
                    // Build combined determinant ND directly: α=ca, β=Sb
                    Determinant ND(2*M);
                    for (auto it = ca.begin_occ(); it != ca.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                    for (auto it = Sb.begin_occ(); it != Sb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));

                    auto itb = BI.map.find(ND);
                    if (itb != BI.map.end()) {
                        const int jcol = itb->second;
                        cx val = KL(D, ND, H, V);
                        if (std::abs(val) >= tol) coo.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                    }
                }
            }
            if (it2 != Ca.Cd.end()) {
                for (const auto& ca : it2->second) {
                    Determinant ND(2*M);
                    for (auto it = ca.begin_occ(); it != ca.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                    for (auto it = Sb.begin_occ(); it != Sb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                    auto itb = BI.map.find(ND);
                    if (itb != BI.map.end()) {
                        const int jcol = itb->second;
                        cx val = KL(D, ND, H, V);
                        if (std::abs(val) >= tol) coo.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                    }
                }
            }
        }

        // --- single/double beta ---
        {
            auto it1 = Cb.Cs.find(Sb);
            auto it2 = Cb.Cd.find(Sb);
            if (it1 != Cb.Cs.end()) {
                for (const auto& cb : it1->second) {
                    Determinant ND(2*M);
                    for (auto it = Sa.begin_occ(); it != Sa.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                    for (auto it = cb.begin_occ(); it != cb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                    auto itb = BI.map.find(ND);
                    if (itb != BI.map.end()) {
                        const int jcol = itb->second;
                        cx val = KL(D, ND, H, V);
                        if (std::abs(val) >= tol) coo.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                    }
                }
            }
            if (it2 != Cb.Cd.end()) {
                for (const auto& cb : it2->second) {
                    Determinant ND(2*M);
                    for (auto it = Sa.begin_occ(); it != Sa.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                    for (auto it = cb.begin_occ(); it != cb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                    auto itb = BI.map.find(ND);
                    if (itb != BI.map.end()) {
                        const int jcol = itb->second;
                        cx val = KL(D, ND, H, V);
                        if (std::abs(val) >= tol) coo.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                    }
                }
            }
        }

        // --- double = single alpha + single beta ---
        {
            auto itSa = Ca.Cs.find(Sa);
            auto itSb = Cb.Cs.find(Sb);
            if (itSa != Ca.Cs.end() && itSb != Cb.Cs.end()) {
                const auto& Va = itSa->second;
                const auto& Vb = itSb->second;
                for (const auto& ca : Va) {
                    for (const auto& cb : Vb) {
                        Determinant ND(2*M);
                        for (auto it = ca.begin_occ(); it != ca.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                        for (auto it = cb.begin_occ(); it != cb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                        auto itb = BI.map.find(ND);
                        if (itb != BI.map.end()) {
                            const int jcol = itb->second;
                            cx val = KL(D, ND, H, V);
                            if (std::abs(val) >= tol) coo.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                        }
                    }
                }
            }
        }

        // --- magnetic interactions ---
        if (enable_magnetic) {
            auto itMa = Ca.Cmag.find(Sa);
            auto itMb = Cb.Cmag.find(Sb);
            if (itMa != Ca.Cmag.end() && itMb != Cb.Cmag.end()) {
                const auto& Ma = itMa->second;
                const auto& Mb = itMb->second;
                for (const auto& ca : Ma) {
                    for (const auto& cb : Mb) {
                        Determinant ND(2*M);
                        for (auto it = ca.begin_occ(); it != ca.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                        for (auto it = cb.begin_occ(); it != cb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));

                        // Mirror your final guard:
                        // if nd!=0 && count_ones(xor(nd, od)) == 2
                        // (nd!=0 is implied here by having at least something changed)
                        const int ham = [&]{
                            const auto& wa = D.bits().words();
                            const auto& wb = ND.bits().words();
                            std::size_t c = 0;
                            for (std::size_t w = 0; w < wa.size(); ++w) c += std::popcount(wa[w] ^ wb[w]);
                            return static_cast<int>(c);
                        }();
                        if (ham == 2) {
                            auto itb = BI.map.find(ND);
                            if (itb != BI.map.end()) {
                                const int jcol = itb->second;
                                cx val = KL(D, ND, H, V);
                                if (std::abs(val) >= tol) coo.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                            }
                        }
                    }
                }
            }
        }
    }

    // Concatenate thread-local COO
    COO all;
    std::size_t total = 0;
    for (const auto& c : tl_coo) total += c.val.size();
    all.row.reserve(total); all.col.reserve(total); all.val.reserve(total);
    for (auto& c : tl_coo) {
        all.row.insert(all.row.end(), c.row.begin(), c.row.end());
        all.col.insert(all.col.end(), c.col.begin(), c.col.end());
        all.val.insert(all.val.end(), c.val.begin(), c.val.end());
    }

    return coo_to_csr(N, N, std::move(all));
}

#ifdef CI_USE_MPI
CSR build_hamiltonian_mpi(const std::vector<SlaterDeterminant>& basis,
                          const H1View& H, const ERIView& V,
                          MPI_Comm comm,
                          bool enable_magnetic,
                          double tol)
{
    int rank = 0, size = 1;
    MPI_Comm_rank(comm, &rank);
    MPI_Comm_size(comm, &size);

    const std::size_t N = basis.size();
    if (N == 0) return CSR{};

    const std::size_t M = basis[0].num_spatial_orbitals();

    // Precompute unique α/β and connections on rank 0, broadcast
    // For simplicity and determinism, recompute on all ranks (as in your broadcast path).
    auto [Ia, Ib] = unique_alpha_beta(basis);
    Connections Ca = Caa(Ia, enable_magnetic);
    Connections Cb = Caa(Ib, enable_magnetic);
    BasisIndex BI = make_basis_index(basis);

    // Partition rows
    std::size_t rows_per = (N + static_cast<std::size_t>(size) - 1) / static_cast<std::size_t>(size);
    std::size_t i0 = static_cast<std::size_t>(rank) * rows_per;
    std::size_t i1 = std::min(N, i0 + rows_per);

    COO local;

    for (std::size_t irow = i0; irow < i1; ++irow) {
        const SlaterDeterminant& S = basis[irow];
        const SpinDeterminant& Sa = S.alpha();
        const SpinDeterminant& Sb = S.beta();

        Determinant D = combined_from(S);
        std::vector<int> occK; occ_list_alpha_beta(S, occK);

        // Diagonal
        {
            cx h = OO(H, V, occK);
            if (std::abs(h) >= tol) local.push(static_cast<int32_t>(irow), static_cast<int32_t>(irow), h, tol);
        }

        // α connections
        {
            auto it1 = Ca.Cs.find(Sa);
            auto it2 = Ca.Cd.find(Sa);
            if (it1 != Ca.Cs.end()) {
                for (const auto& ca : it1->second) {
                    Determinant ND(2*M);
                    for (auto it = ca.begin_occ(); it != ca.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                    for (auto it = Sb.begin_occ(); it != Sb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                    auto itb = BI.map.find(ND);
                    if (itb != BI.map.end()) {
                        const int jcol = itb->second;
                        cx val = KL(D, ND, H, V);
                        if (std::abs(val) >= tol) local.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                    }
                }
            }
            if (it2 != Ca.Cd.end()) {
                for (const auto& ca : it2->second) {
                    Determinant ND(2*M);
                    for (auto it = ca.begin_occ(); it != ca.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                    for (auto it = Sb.begin_occ(); it != Sb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                    auto itb = BI.map.find(ND);
                    if (itb != BI.map.end()) {
                        const int jcol = itb->second;
                        cx val = KL(D, ND, H, V);
                        if (std::abs(val) >= tol) local.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                    }
                }
            }
        }

        // β connections
        {
            auto it1 = Cb.Cs.find(Sb);
            auto it2 = Cb.Cd.find(Sb);
            if (it1 != Cb.Cs.end()) {
                for (const auto& cb : it1->second) {
                    Determinant ND(2*M);
                    for (auto it = Sa.begin_occ(); it != Sa.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                    for (auto it = cb.begin_occ(); it != cb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                    auto itb = BI.map.find(ND);
                    if (itb != BI.map.end()) {
                        const int jcol = itb->second;
                        cx val = KL(D, ND, H, V);
                        if (std::abs(val) >= tol) local.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                    }
                }
            }
            if (it2 != Cb.Cd.end()) {
                for (const auto& cb : it2->second) {
                    Determinant ND(2*M);
                    for (auto it = Sa.begin_occ(); it != Sa.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                    for (auto it = cb.begin_occ(); it != cb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                    auto itb = BI.map.find(ND);
                    if (itb != BI.map.end()) {
                        const int jcol = itb->second;
                        cx val = KL(D, ND, H, V);
                        if (std::abs(val) >= tol) local.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                    }
                }
            }
        }

        // α×β singles
        {
            auto itSa = Ca.Cs.find(Sa);
            auto itSb = Cb.Cs.find(Sb);
            if (itSa != Ca.Cs.end() && itSb != Cb.Cs.end()) {
                for (const auto& ca : itSa->second) {
                    for (const auto& cb : itSb->second) {
                        Determinant ND(2*M);
                        for (auto it = ca.begin_occ(); it != ca.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                        for (auto it = cb.begin_occ(); it != cb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));
                        auto itb = BI.map.find(ND);
                        if (itb != BI.map.end()) {
                            const int jcol = itb->second;
                            cx val = KL(D, ND, H, V);
                            if (std::abs(val) >= tol) local.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                        }
                    }
                }
            }
        }

        // magnetic
        if (enable_magnetic) {
            auto itMa = Ca.Cmag.find(Sa);
            auto itMb = Cb.Cmag.find(Sb);
            if (itMa != Ca.Cmag.end() && itMb != Cb.Cmag.end()) {
                for (const auto& ca : itMa->second) {
                    for (const auto& cb : itMb->second) {
                        Determinant ND(2*M);
                        for (auto it = ca.begin_occ(); it != ca.end_occ(); ++it) ND.set(static_cast<std::size_t>(*it));
                        for (auto it = cb.begin_occ(); it != cb.end_occ(); ++it) ND.set(static_cast<std::size_t>(M + *it));

                        // Guard: xor popcount == 2
                        const int ham = [&]{
                            const auto& wa = D.bits().words();
                            const auto& wb = ND.bits().words();
                            std::size_t c = 0;
                            for (std::size_t w = 0; w < wa.size(); ++w) c += std::popcount(wa[w] ^ wb[w]);
                            return static_cast<int>(c);
                        }();
                        if (ham == 2) {
                            auto itb = BI.map.find(ND);
                            if (itb != BI.map.end()) {
                                const int jcol = itb->second;
                                cx val = KL(D, ND, H, V);
                                if (std::abs(val) >= tol) local.push(static_cast<int32_t>(irow), static_cast<int32_t>(jcol), val, tol);
                            }
                        }
                    }
                }
            }
        }
    }

    // Gather to rank 0
    std::int64_t local_nnz = static_cast<std::int64_t>(local.val.size());
    std::vector<std::int64_t> counts(size);
    MPI_Allgather(&local_nnz, 1, MPI_LONG_LONG, counts.data(), 1, MPI_LONG_LONG, comm);

    std::int64_t total_nnz = 0;
    std::vector<std::int64_t> displs(size, 0);
    for (int r = 0; r < size; ++r) { displs[r] = total_nnz; total_nnz += counts[r]; }

    // Prepare recv buffers on root
    std::vector<int32_t> R_row, R_col;
    std::vector<cx>      R_val;
    if (rank == 0) {
        R_row.resize(static_cast<std::size_t>(total_nnz));
        R_col.resize(static_cast<std::size_t>(total_nnz));
        R_val.resize(static_cast<std::size_t>(total_nnz));
    }

    // Gatherv rows/cols/vals
    MPI_Gatherv(local.row.data(), static_cast<int>(local.row.size()), MPI_INT,
                R_row.data(), reinterpret_cast<int*>(counts.data()),
                reinterpret_cast<int*>(displs.data()), MPI_INT, 0, comm);
    MPI_Gatherv(local.col.data(), static_cast<int>(local.col.size()), MPI_INT,
                R_col.data(), reinterpret_cast<int*>(counts.data()),
                reinterpret_cast<int*>(displs.data()), MPI_INT, 0, comm);
    MPI_Gatherv(local.val.data(), static_cast<int>(local.val.size()), MPI_CXX_DOUBLE_COMPLEX,
                R_val.data(), reinterpret_cast<int*>(counts.data()),
                reinterpret_cast<int*>(displs.data()), MPI_CXX_DOUBLE_COMPLEX, 0, comm);

    if (rank == 0) {
        COO all;
        all.row = std::move(R_row);
        all.col = std::move(R_col);
        all.val = std::move(R_val);
        return coo_to_csr(N, N, std::move(all));
    } else {
        return CSR{};
    }
}
#endif

CSR build_hamiltonian_naive(const std::vector<SlaterDeterminant>& basis,
                            const H1View& H, const ERIView& V,
                            double tol)
{
    const std::size_t N = basis.size();
    if (N == 0) return CSR{};

    // Precompute combined determinants once
    std::vector<Determinant> Dlist; Dlist.reserve(N);
    for (std::size_t i = 0; i < N; ++i)
        Dlist.push_back(combined_from(basis[i]));

    // Thread-local COO buffers
    const int nthreads =
    #ifdef _OPENMP
        omp_get_max_threads();
    #else
        1;
    #endif
    std::vector<COO> tl_coo(static_cast<std::size_t>(nthreads));

    // Naive double loop (outer-parallel if OpenMP is available)
    #pragma omp parallel for schedule(static)
    for (std::int64_t i = 0; i < static_cast<std::int64_t>(N); ++i) {
        const int tid =
        #ifdef _OPENMP
            omp_get_thread_num();
        #else
            0;
        #endif
        COO& coo = tl_coo[static_cast<std::size_t>(tid)];

        const Determinant& Di = Dlist[static_cast<std::size_t>(i)];
        for (std::size_t j = 0; j < N; ++j) {
            const Determinant& Dj = Dlist[j];
            cx val = KL(Di, Dj, H, V);          // exact Slater–Condon dispatcher
            if (std::abs(val) >= tol) {
                coo.push(static_cast<int32_t>(i), static_cast<int32_t>(j), val, tol);
            }
        }
    }

    // Concatenate thread-local COO and pack to CSR
    COO all;
    std::size_t total = 0;
    for (const auto& c : tl_coo) total += c.val.size();
    all.row.reserve(total); all.col.reserve(total); all.val.reserve(total);
    for (auto& c : tl_coo) {
        all.row.insert(all.row.end(), c.row.begin(), c.row.end());
        all.col.insert(all.col.end(), c.col.begin(), c.col.end());
        all.val.insert(all.val.end(), c.val.begin(), c.val.end());
    }

    return coo_to_csr(N, N, std::move(all));
}

} // namespace ci// cpp_src/applyH.cpp
#include "applyH.h"
#include "ci_core.h"
#include "slater_condon.h"
#include <algorithm>
#include <cmath>
#include <cstdint>
#include <omp.h>
#include <unordered_set>
#include <vector>

namespace ci {

// Helper to create a combined spin-orbital determinant from a SlaterDeterminant
static inline Determinant combined_from(const SlaterDeterminant& sd) {
    const size_t M = sd.num_spatial_orbitals();
    Determinant D(2 * M);
    for (auto it = sd.alpha().begin_occ(); it != sd.alpha().end_occ(); ++it)
        D.set((size_t)*it);
    for (auto it = sd.beta().begin_occ(); it != sd.beta().end_occ(); ++it)
        D.set(M + (size_t)*it);
    return D;
}


MoveTables build_move_tables(size_t K, const H1View& H, const ERIView& V, double tol) {
    MoveTables mt;
    mt.n_spin_orbitals = K;

    // --- Build Singles Table ---
    std::vector<std::unordered_set<uint32_t>> temp_singles(K);
    for (uint32_t r = 0; r < K; ++r) {
        for (uint32_t p = 0; p < K; ++p) {
            if (p == r) continue;
            if (std::abs(H(p, r)) >= tol) {
                temp_singles[r].insert(p);
                continue;
            }
            for (uint32_t s = 0; s < K; ++s) {
                if (std::abs(V(p,s,r,s) - V(p,s,s,r)) >= tol) {
                    temp_singles[r].insert(p);
                    break;
                }
            }
        }
    }
    for (uint32_t r = 0; r < K; ++r) {
        if (!temp_singles[r].empty()) {
            mt.singles[r].assign(temp_singles[r].begin(), temp_singles[r].end());
        }
    }

    // --- Build Doubles Table ---
    for (uint32_t r = 0; r < K; ++r) {
        for (uint32_t s = r + 1; s < K; ++s) {
            uint64_t key_rs = ((uint64_t)r << 32) | s;
            std::unordered_set<uint64_t> targets;

            for (uint32_t p = 0; p < K; ++p) {
                for (uint32_t q = p + 1; q < K; ++q) {
                    // bar{v}_{pq,rs} = (pq|rs) - (pq|sr)
                    if (std::abs(V(p,q,r,s) - V(p,q,s,r)) >= tol) {
                        uint64_t val_pq = ((uint64_t)p << 32) | q;
                        targets.insert(val_pq);
                    }
                }
            }
            if (!targets.empty()) {
                mt.doubles[key_rs].assign(targets.begin(), targets.end());
            }
        }
    }
    return mt;
}

Wavefunction apply_H_on_psi(const Wavefunction& psi, const H1View& H,
                            const ERIView& V, double tol_build, double tol_element) {
    const size_t K = psi.num_spatial_orbitals() * 2;
    MoveTables mt = build_move_tables(K, H, V, tol_build);
    return apply_H_on_psi_with_tables(psi, mt, H, V, tol_element);
}

Wavefunction apply_H_on_psi_with_tables(const Wavefunction& psi, const MoveTables& mt,
                                        const H1View& H, const ERIView& V, double tol_element) {
    using Coeff = Wavefunction::Coeff;
    using Map = std::unordered_map<SlaterDeterminant, Coeff>;

    const size_t M = psi.num_spatial_orbitals();
    std::vector<std::pair<SlaterDeterminant, Coeff>> items;
    items.reserve(psi.data().size());
    for (const auto& kv : psi.data()) {
        items.emplace_back(kv.first, kv.second);
    }

    int T = 1;
    #ifdef _OPENMP
    T = omp_get_max_threads();
    #endif
    std::vector<Map> local_maps(T);

    #pragma omp parallel for schedule(dynamic)
    for (size_t i = 0; i < items.size(); ++i) {
        int tid = 0;
        #ifdef _OPENMP
        tid = omp_get_thread_num();
        #endif
        auto& acc = local_maps[tid];
        const auto& [det_in, coeff] = items[i];

        Determinant d_in_comb = combined_from(det_in);
        
        std::vector<int> occ_so;
        occ_so.reserve(M * 2);
        for(auto it = det_in.alpha().begin_occ(); it != det_in.alpha().end_occ(); ++it) occ_so.push_back(*it);
        for(auto it = det_in.beta().begin_occ(); it != det_in.beta().end_occ(); ++it) occ_so.push_back(*it + (int)M);
        std::sort(occ_so.begin(), occ_so.end());

        // --- Diagonal ---
        // This is calculated once and only once.
        acc[det_in] += coeff * OO(H, V, occ_so);

        SlaterDeterminant det_out(M);
        int8_t sign;

        // --- Singles ---
        for (int r : occ_so) {
            auto it = mt.singles.find(r);
            if (it == mt.singles.end()) continue;
            for (uint32_t p : it->second) {
                // Skip the diagonal contribution, it's already handled.
                if ((uint32_t)r == p) continue;

                if (SlaterDeterminant::apply_excitation_single_fast(
                        det_in, p % M, r % M,
                        p < M ? Spin::Alpha : Spin::Beta,
                        r < M ? Spin::Alpha : Spin::Beta,
                        det_out, sign)) {
                    
                    // Swap arguments to KL to get <bra|H|ket> = <det_out|H|det_in>
                    Determinant d_out_comb = combined_from(det_out);
                    acc[det_out] += coeff * KL(d_out_comb, d_in_comb, H, V);
                }
            }
        }

        // --- Doubles ---
        for (size_t j = 0; j < occ_so.size(); ++j) {
            for (size_t k = j + 1; k < occ_so.size(); ++k) {
                uint32_t r = (uint32_t)occ_so[j];
                uint32_t s = (uint32_t)occ_so[k];
                uint64_t key_rs = ((uint64_t)r << 32) | s;

                auto it = mt.doubles.find(key_rs);
                if (it == mt.doubles.end()) continue;

                for (uint64_t val_pq : it->second) {
                    uint32_t p = (uint32_t)(val_pq >> 32);
                    uint32_t q = (uint32_t)(val_pq & 0xFFFFFFFF);                
                    
                    if (SlaterDeterminant::apply_excitation_double_fast(
                            det_in, p % M, q % M, r % M, s % M,
                            p < M ? Spin::Alpha : Spin::Beta,
                            q < M ? Spin::Alpha : Spin::Beta,
                            r < M ? Spin::Alpha : Spin::Beta,
                            s < M ? Spin::Alpha : Spin::Beta,
                            det_out, sign)) {
                        
                        // FIX 2: Swap arguments to KL to get <bra|H|ket> = <det_out|H|det_in>
                        Determinant d_out_comb = combined_from(det_out);
                        acc[det_out] += coeff * KL(d_out_comb, d_in_comb, H, V);
                    }
                }
            }
        }
    }

    // --- Merge results ---
    Map final_acc;
    size_t hint = 0;
    for(const auto& m : local_maps) hint += m.size();
    final_acc.reserve(hint);
    for (const auto& m : local_maps) {
        for (const auto& kv : m) {
            final_acc[kv.first] += kv.second;
        }
    }

    Wavefunction out(M);
    for (const auto& kv : final_acc) {
        out.add_term(kv.first, kv.second, tol_element);
    }
    return out;
}

} // namespace ci#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include <pybind11/operators.h>
#include <pybind11/complex.h>
#include <pybind11/stl_bind.h>

#include "ci_core.h"
#include "slater_condon.h"
#include "hamiltonian.h"
#include "ed_tools.h"
#include "applyH.h"

#include <complex>
#include <vector>
#include <stdexcept>
#include <tuple>

namespace py = pybind11;
using namespace ci;
using cx = std::complex<double>;


// ---------------------- helpers: SciPy CSR constructors ----------------------

static py::object scipy_csr_from_CSR(const CSR& csr)
{
    py::module_ sp_sparse = py::module_::import("scipy.sparse");
    auto np_data   = py::array_t<cx>(csr.data.size(), csr.data.data());
    auto np_indices= py::array_t<int32_t>(csr.indices.size(), csr.indices.data());
    auto np_indptr = py::array_t<int64_t>(csr.indptr.size(), csr.indptr.data());
    py::tuple shape = py::make_tuple((py::int_)csr.n_rows, (py::int_)csr.n_cols);
    return sp_sparse.attr("csr_matrix")(py::make_tuple(np_data, np_indices, np_indptr),
                                        py::arg("shape")=shape);
}

static py::object scipy_csr_from_triplets(
    int dim, const std::vector<Triplet>& triplets)
{
    py::module_ sp_sparse = py::module_::import("scipy.sparse");
    std::vector<int> rows, cols;
    std::vector<cx> vals;
    rows.reserve(triplets.size());
    cols.reserve(triplets.size());
    vals.reserve(triplets.size());
    for (const auto& t : triplets) {
        rows.push_back(t.row);
        cols.push_back(t.col);
        vals.push_back(t.value);
    }
    auto np_data = py::array_t<cx>(vals.size(), vals.data());
    auto np_rows = py::array_t<int>(rows.size(), rows.data());
    auto np_cols = py::array_t<int>(cols.size(), cols.data());
    py::tuple ij = py::make_tuple(np_rows, np_cols);
    py::tuple data_ij = py::make_tuple(np_data, ij);
    py::tuple shape = py::make_tuple(dim, dim);
    return sp_sparse.attr("csr_matrix")(data_ij, py::arg("shape")=shape);
}

// --------------------------- wrap ED tools -----------------------------------

py::object get_annihilation_operator_py(int num_spin_orbitals, int orbital_index_1based)
{
    int i0 = orbital_index_1based - 1;
    auto triplets = get_annihilation_operator_sparse(num_spin_orbitals, i0);
    int dim = 1 << num_spin_orbitals;
    return scipy_csr_from_triplets(dim, triplets);
}

py::object get_creation_operator_py(int num_spin_orbitals, int orbital_index_1based)
{
    int i0 = orbital_index_1based - 1;
    auto triplets = get_creation_operator_sparse(num_spin_orbitals, i0);
    int dim = 1 << num_spin_orbitals;
    return scipy_csr_from_triplets(dim, triplets);
}

// ------------------- helpers: array views -----------------

static H1View make_H1(py::array H) {
    py::buffer_info buf = H.request();
    if (buf.ndim != 2 || buf.shape[0] != buf.shape[1])
        throw std::runtime_error("H must be a square 2D NumPy array.");
    return H1View{reinterpret_cast<const cx*>(buf.ptr), (size_t)buf.shape[0]};
}

static ERIView make_ERI(py::array V) {
    py::buffer_info buf = V.request();
    if (buf.ndim != 4 || buf.shape[0] != buf.shape[1] || buf.shape[0] != buf.shape[2] || buf.shape[0] != buf.shape[3])
        throw std::runtime_error("V must be a 4D NumPy array of shape (K,K,K,K).");
    return ERIView{reinterpret_cast<const cx*>(buf.ptr), (size_t)buf.shape[0]};
}

// -------------------------- Hamiltonian wrappers -----------------------------

py::object build_ham_naive_py(const std::vector<SlaterDeterminant>& basis,
                              py::array H, py::array V, double tol)
{
    if (basis.empty()) return py::none();
    CSR csr = build_hamiltonian_naive(basis, make_H1(H), make_ERI(V), tol);
    return scipy_csr_from_CSR(csr);
}

py::object build_ham_openmp_py(const std::vector<SlaterDeterminant>& basis,
                               py::array H, py::array V,
                               bool enable_magnetic, double tol)
{
    if (basis.empty()) return py::none();
    CSR csr = build_hamiltonian_openmp(basis, make_H1(H), make_ERI(V), enable_magnetic, tol);
    return scipy_csr_from_CSR(csr);
}


// --------------------------------- Module Definition ------------------------------------
PYBIND11_MODULE(clic_clib, m) {
m.doc() = R"doc(
    High-performance C++ backend for Configuration Interaction (CI) calculations.

    This library provides core data structures for representing Slater determinants
    and wavefunctions, efficient C++ kernels for applying operators and building
    Hamiltonian matrices using Slater-Condon rules, and tools for dynamic
    operator application.
)doc";

    // --- Enums ---
    py::enum_<Spin>(m, "Spin")
        .value("Alpha", Spin::Alpha)
        .value("Beta", Spin::Beta)
        .export_values();

    py::enum_<SpinOrbitalOrder>(m, "SpinOrbitalOrder")
        .value("AlphaFirst", SpinOrbitalOrder::AlphaFirst)
        .value("Interleaved", SpinOrbitalOrder::Interleaved)
        .export_values();
        
    // --- Result Struct for Operators ---
    py::class_<SlaterDeterminant::OpResult>(m, "SlaterDeterminantOpResult")
        .def_readonly("det", &SlaterDeterminant::OpResult::det)
        .def_readonly("sign", &SlaterDeterminant::OpResult::sign)
        .def("__repr__", [](const SlaterDeterminant::OpResult &res) {
            return "<SlaterDeterminantOpResult: sign=" + std::to_string(res.sign) + ">";
        });

    // --- Core Classes ---
    py::class_<SlaterDeterminant>(m, "SlaterDeterminant","Represents a Slater determinant with separate alpha and beta spin strings.")
        .def(py::init<std::size_t, const std::vector<int>&, const std::vector<int>&>(),
             py::arg("n_spatial"), py::arg("occ_alpha0"), py::arg("occ_beta0"),"Constructs a determinant for M spatial orbitals with given occupations.")
        .def("alpha_occupied_indices", [](const SlaterDeterminant& det) {
            std::vector<int> occ;
            for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) occ.push_back(*it);
            return occ;
        })
        .def("beta_occupied_indices", [](const SlaterDeterminant& det) {
            std::vector<int> occ;
            for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it) occ.push_back(*it);
            return occ;
        })
        .def_static("create", &SlaterDeterminant::create, py::arg("s"), py::arg("i0"), py::arg("spin"), 
                    py::arg("order") = SpinOrbitalOrder::AlphaFirst)
        .def_static("annihilate", &SlaterDeterminant::annihilate, py::arg("s"), py::arg("i0"), py::arg("spin"),
                    py::arg("order") = SpinOrbitalOrder::AlphaFirst)
        .def_static("apply_excitation_single", &SlaterDeterminant::apply_excitation_single)
        .def_static("apply_excitation_double", &SlaterDeterminant::apply_excitation_double)
        .def_property_readonly("n_spatial", &SlaterDeterminant::num_spatial_orbitals)
        .def("get_occupied_spin_orbitals", [](const SlaterDeterminant& det) {
            std::vector<int> occ;
            const auto M = det.num_spatial_orbitals();
            for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) occ.push_back(*it);
            for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it) occ.push_back(*it + static_cast<int>(M));
            std::sort(occ.begin(), occ.end()); // Return in sorted order
            return occ;
        }, "Returns the combined list of occupied spin-orbital indices (AlphaFirst ordering).")
        .def(py::self < py::self)
        .def(py::self == py::self)
        .def(py::hash(py::self))
        .def("__repr__", [](const SlaterDeterminant& det) {
            py::list alpha, beta;
            for (auto it = det.alpha().begin_occ(); it != det.alpha().end_occ(); ++it) alpha.append(*it);
            for (auto it = det.beta().begin_occ(); it != det.beta().end_occ(); ++it) beta.append(*it);
            return "<SlaterDeterminant α=" + std::string(py::str(alpha)) + " β=" + std::string(py::str(beta)) + ">";
        });
    
    py::class_<Wavefunction>(m, "Wavefunction")
        .def(py::init<std::size_t>(), py::arg("n_spatial"))

        .def(py::init<std::size_t, const Wavefunction::Data&>(),
         py::arg("n_spatial"), py::arg("data"))
         
        // Constructor from basis and amplitudes
        .def(py::init<std::size_t, const std::vector<SlaterDeterminant>&, const std::vector<Wavefunction::Coeff>&, bool>(),
         py::arg("n_spatial"), py::arg("basis"), py::arg("amplitudes"), py::arg("keep_zeros") = true)


        .def("add_term", &Wavefunction::add_term, py::arg("det"), py::arg("coeff"), py::arg("tol") = 0)

        .def("add_wavefunction", &Wavefunction::add_wavefunction, 
         py::arg("other"), py::arg("scale") = cx{1.0, 0.0},
         "Adds another wavefunction scaled by a coefficient, modifying this one in-place.")

        .def("data", &Wavefunction::data, py::return_value_policy::reference_internal)
        .def("prune", &Wavefunction::prune, py::arg("threshold"))
        .def("normalize", &Wavefunction::normalize, py::arg("tol") = 1e-15)
        .def("dot", &Wavefunction::dot, py::arg("other"), "Computes dot product <self|other>")

        .def("__iadd__", [](Wavefunction &wf, const Wavefunction &other) { wf.add_wavefunction(other); return wf; }, py::is_operator())

        .def("__add__", [](const Wavefunction &wf, const Wavefunction &other) { Wavefunction result = wf; result.add_wavefunction(other); return result; }, py::is_operator())
        .def("__sub__", [](const Wavefunction &wf, const Wavefunction &other) { Wavefunction result = wf; result.add_wavefunction(other, {-1.0, 0.0}); return result; }, py::is_operator())
        .def("__mul__", [](const Wavefunction &wf, cx scale) { Wavefunction result(wf.num_spatial_orbitals()); for (const auto& [det, coeff] : wf.data()) { result.add_term(det, coeff * scale); } return result; }, py::is_operator())
        .def("__rmul__", [](const Wavefunction &wf, cx scale) { Wavefunction result(wf.num_spatial_orbitals()); for (const auto& [det, coeff] : wf.data()) { result.add_term(det, coeff * scale); } return result; }, py::is_operator())
        .def("get_basis", &Wavefunction::basis_sorted, "Returns a sorted list of SlaterDeterminant objects in the wavefunction.")
        .def("get_amplitudes", [](Wavefunction& wf) {
            auto basis = wf.basis_sorted();
            auto coeffs_vec = wf.coeffs_sorted(basis);
            return py::array_t<cx>(coeffs_vec.size(), coeffs_vec.data());
        }, "Returns a NumPy array of amplitudes, sorted according to the basis.")
        .def_property_readonly("n_spatial", &Wavefunction::num_spatial_orbitals)
        .def("__repr__", [](const Wavefunction& wf) {
            return "<Wavefunction with " + std::to_string(wf.data().size()) + " terms>";
        });

    m.def("apply_creation", &apply_creation, py::arg("wf"), py::arg("i0"), py::arg("spin"),
          py::arg("order") = SpinOrbitalOrder::AlphaFirst);
    m.def("apply_annihilation", &apply_annihilation, py::arg("wf"), py::arg("i0"), py::arg("spin"),
          py::arg("order") = SpinOrbitalOrder::AlphaFirst);

    // Some useful accesses 
    // Return coeff if present, else 0+0j
    m.attr("Wavefunction").cast<py::class_<Wavefunction>>()
        .def("amplitude", [](const Wavefunction& wf, const SlaterDeterminant& det) {
            const auto& M = wf.data();                // const ref to unordered_map
            auto it = M.find(det);
            return (it == M.end()) ? cx{0.0, 0.0} : it->second;
        }, py::arg("det"), R"doc(Returns ⟨det|ψ⟩, or 0 if absent.)doc")


        // Pythonic containment test: `det in wf`
        .def("__contains__", [](const Wavefunction& wf, const SlaterDeterminant& det) {
            return wf.data().find(det) != wf.data().end();
        }, py::arg("det"));

    // --- Wavefunction Operator Functions (MODIFIED SECTION) ---
    // Use lambdas to convert Python list of tuples to C++ vector of structs
    m.def("apply_one_body_operator",
          [](const Wavefunction& wf, const std::vector<std::tuple<size_t, size_t, Spin, Spin, Wavefunction::Coeff>>& term_tuples) {
              std::vector<OneBodyTerm> terms;
              terms.reserve(term_tuples.size());
              for (const auto& t : term_tuples) {
                  terms.emplace_back(OneBodyTerm{
                      std::get<0>(t), std::get<1>(t),
                      std::get<2>(t), std::get<3>(t),
                      std::get<4>(t)
                  });
              }
              return apply_one_body_operator(wf, terms);
          },
          py::arg("wf"), py::arg("terms"));

    m.def("apply_two_body_operator",
          [](const Wavefunction& wf, const std::vector<std::tuple<size_t, size_t, size_t, size_t, Spin, Spin, Spin, Spin, Wavefunction::Coeff>>& term_tuples) {
              std::vector<TwoBodyTerm> terms;
              terms.reserve(term_tuples.size());
              for (const auto& t : term_tuples) {
                  terms.emplace_back(TwoBodyTerm{
                      std::get<0>(t), std::get<1>(t), std::get<2>(t), std::get<3>(t),
                      std::get<4>(t), std::get<5>(t), std::get<6>(t), std::get<7>(t),
                      std::get<8>(t)
                  });
              }
              return apply_two_body_operator(wf, terms);
          },
          py::arg("wf"), py::arg("terms"));

    // --- Basis Connectivity Functions (MODIFIED SECTION) ---
    m.def("get_connections_one_body",
          [](const std::vector<SlaterDeterminant>& basis, const std::vector<std::tuple<size_t, size_t, Spin, Spin, Wavefunction::Coeff>>& term_tuples) {
              std::vector<OneBodyTerm> terms;
              terms.reserve(term_tuples.size());
              for (const auto& t : term_tuples) {
                  terms.emplace_back(OneBodyTerm{
                      std::get<0>(t), std::get<1>(t),
                      std::get<2>(t), std::get<3>(t),
                      std::get<4>(t)
                  });
              }
              return get_connections_one_body(basis, terms);
          },
          py::arg("basis"), py::arg("terms"));

    m.def("get_connections_two_body",
          [](const std::vector<SlaterDeterminant>& basis, const std::vector<std::tuple<size_t, size_t, size_t, size_t, Spin, Spin, Spin, Spin, Wavefunction::Coeff>>& term_tuples) {
              std::vector<TwoBodyTerm> terms;
              terms.reserve(term_tuples.size());
              for (const auto& t : term_tuples) {
                  terms.emplace_back(TwoBodyTerm{
                      std::get<0>(t), std::get<1>(t), std::get<2>(t), std::get<3>(t),
                      std::get<4>(t), std::get<5>(t), std::get<6>(t), std::get<7>(t),
                      std::get<8>(t)
                  });
              }
              return get_connections_two_body(basis, terms);
          },
          py::arg("basis"), py::arg("terms"));


    // --- Table-driven Hamiltonian Application (applyH) ---
    py::class_<MoveTables>(m, "MoveTables", "Pre-computed tables for efficient H|psi> application.")
        .def(py::init<>())
        .def("__repr__", [](const MoveTables& mt) {
            // Correctly access n_spin_orbitals and clarify the output string
            return "<MoveTables for K=" + std::to_string(mt.n_spin_orbitals) + " spin-orbitals>";
        });

    m.def("build_move_tables",
        [](py::array H, py::array V, double tol) {
            size_t K = H.request().shape[0];
            return build_move_tables(K, make_H1(H), make_ERI(V), tol);
        },
        py::arg("H"), py::arg("V"), py::arg("tol_build"),
        R"doc(
        Builds pre-computed screening tables for fast Hamiltonian application.

        Args:
            H (np.ndarray): The (K, K) one-electron integral matrix (spin-orbital basis).
            V (np.ndarray): The (K, K, K, K) two-electron integral tensor (spin-orbital basis).
            tol_build (float): Tolerance for screening integrals during table construction.

        Returns:
            MoveTables: An opaque object containing the screening tables.
    )doc");

    m.def("apply_hamiltonian_with_tables",
        [](const Wavefunction& psi, const MoveTables& mt, py::array H, py::array V, double tol) {
            return apply_H_on_psi_with_tables(psi, mt, make_H1(H), make_ERI(V), tol);
        },
        py::arg("psi"), py::arg("tables"), py::arg("H"), py::arg("V"), py::arg("tol_element"),
        R"doc(
        Applies the Hamiltonian to a wavefunction using pre-built screening tables.

        This is the recommended high-performance function for iterative algorithms.

        Args:
            psi (Wavefunction): The input wavefunction.
            tables (MoveTables): Pre-computed tables from build_move_tables.
            H (np.ndarray): The (K, K) one-electron integral matrix.
            V (np.ndarray): The (K, K, K, K) two-electron integral tensor.
            tol_element (float): Tolerance for screening final matrix elements.

        Returns:
            Wavefunction: The resulting wavefunction H|psi>.
    )doc");

    m.def("apply_hamiltonian",
        [](const Wavefunction& psi, py::array H, py::array V, double tol_build, double tol_element) {
            return apply_H_on_psi(psi, make_H1(H), make_ERI(V), tol_build, tol_element);
        },
        py::arg("psi"), py::arg("H"), py::arg("V"), py::arg("tol_build"), py::arg("tol_element"),
        R"doc(
        Applies the Hamiltonian to a wavefunction (builds tables internally).

        Convenience function that combines table building and application. Less efficient
        for repeated applications.

        Args:
            psi (Wavefunction): The input wavefunction.
            H (np.ndarray): The (K, K) one-electron integral matrix.
            V (np.ndarray): The (K, K, K, K) two-electron integral tensor.
            tol_build (float): Tolerance for screening integrals.
            tol_element (float): Tolerance for screening final matrix elements.

        Returns:
            Wavefunction: The resulting wavefunction H|psi>.
    )doc");




    // --- ED Tools & Hamiltonian Construction ---
    m.def("get_annihilation_operator", &get_annihilation_operator_py,
          py::arg("num_spin_orbitals"), py::arg("orbital_index_1based"));
    m.def("get_creation_operator", &get_creation_operator_py,
          py::arg("num_spin_orbitals"), py::arg("orbital_index_1based"));

    m.def("build_hamiltonian_naive", &build_ham_naive_py,
      py::arg("basis"), py::arg("H"), py::arg("V"), py::arg("tol") = 1e-16);

    m.def("build_hamiltonian_openmp", &build_ham_openmp_py,
          py::arg("basis"), py::arg("H"), py::arg("V"),
          py::arg("enable_magnetic") = true, py::arg("tol") = 1e-16,R"doc(
        Builds the sparse Hamiltonian matrix for a given basis using OpenMP.

        This is the main high-performance function for constructing the CI matrix.
        It expects integrals in the 'AlphaFirst' basis ordering.

        Args:
            basis (list[SlaterDeterminant]): A list of SlaterDeterminant objects defining the basis.
            H (np.ndarray): The (K, K) one-electron integral matrix (complex128, C-contiguous).
            V (np.ndarray): The (K, K, K, K) two-electron integral tensor (complex128, C-contiguous).
            enable_magnetic (bool): Flag to include magnetic interactions (default: True).
            tol (float): Tolerance below which matrix elements are considered zero.

        Returns:
            scipy.sparse.csr_matrix: The Hamiltonian matrix in sparse CSR format.
    )doc");

    m.def("KL", [](const std::vector<int>& occ1, const std::vector<int>& occ2, size_t K,
                   py::array H, py::array V) {
        Determinant D1(K, occ1);
        Determinant D2(K, occ2);
        return KL(D1, D2, make_H1(H), make_ERI(V));
    }, py::arg("occ1"), py::arg("occ2"), py::arg("K"), py::arg("H"), py::arg("V"));
}
